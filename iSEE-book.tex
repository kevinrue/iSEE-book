% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Extending iSEE},
  pdfauthor={Kevin Rue-Albrecht, Federico Marini, Charlotte Soneson, and Aaron Lun},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Extending \emph{iSEE}}
\author{Kevin Rue-Albrecht, Federico Marini, Charlotte Soneson, and Aaron Lun}
\date{2020-07-05}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

The \href{https://bioconductor.org/}{Bioconductor} package \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} provides functions to create an interactive graphical user interface (GUI) using the \href{https://rstudio.com/}{RStudio} \emph{\href{https://CRAN.R-project.org/package=Shiny}{Shiny}} package for exploring data stored in \emph{\href{https://bioconductor.org/packages/3.11/SummarizedExperiment}{SummarizedExperiment}} objects \citep{rue2018isee}.
This book describes how to use \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}}'s application programming interface (API) to develop new panel types for custom visualizations.
We also present case studies to illustrate the development process for a variety of custom panels.

The contents of this book are intended for developers of custom panel classes, usually inside a dedicated package like \emph{\href{https://bioconductor.org/packages/3.11/iSEEu}{iSEEu}}.
Potential end-users of \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} should refer to the vignettes provided on the package landing page.

\hypertarget{part-api-overview}{%
\part{API overview}\label{part-api-overview}}

\hypertarget{panels}{%
\chapter{Panel classes}\label{panels}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

This chapter provides a list of all of the classes that are implemented by the core \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} package.
Each class comes with its specialized implementations of methods for various generics described in Chapter \ref{api}.
Thus, it is often possible for developers to inherit from one of these classes to get most of the methods implemented ``for free''.
The classes themselves are either virtual or concrete; the latter can be created and used directly in an \texttt{iSEE()} application, while the former can only be used as a parent of a concrete subclass.
Here, we will provide a brief summary of each class along with a listing of its available slots.
Readers should refer to the documentation for each class (links below) for more details.

\hypertarget{virtual-classes}{%
\section{Virtual classes}\label{virtual-classes}}

\hypertarget{panel}{%
\subsection{\texorpdfstring{\texttt{Panel}}{Panel}}\label{panel}}

The \href{https://isee.github.io/iSEE/reference/Panel-class.html}{\texttt{Panel}} class is the base class for all \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} panels.
It provides functionality to control general panel parameters such as the panel width and height.
It also controls the transmission of multiple row/column selections across panels.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"Panel"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "PanelId"                      "PanelHeight"                 
##  [3] "PanelWidth"                   "SelectionBoxOpen"            
##  [5] "RowSelectionSource"           "ColumnSelectionSource"       
##  [7] "DataBoxOpen"                  "RowSelectionDynamicSource"   
##  [9] "RowSelectionType"             "RowSelectionSaved"           
## [11] "ColumnSelectionDynamicSource" "ColumnSelectionType"         
## [13] "ColumnSelectionSaved"         "SelectionHistory"
\end{verbatim}

\hypertarget{dotplot}{%
\subsection{\texorpdfstring{\texttt{DotPlot}}{DotPlot}}\label{dotplot}}

The \href{https://isee.github.io/iSEE/reference/DotPlot-class.html}{\texttt{DotPlot}} class inherits from the \texttt{Panel} class and is the base class for dot-based plots.
This refers to all plots where each row or column is represented by no more than one dot/point on the plot.
It provides functionality to create the plot, control the aesthetics of the points and to manage the brush/lasso selection.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"DotPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "FacetByRow"                   "FacetByColumn"               
##  [3] "ColorBy"                      "ColorByDefaultColor"         
##  [5] "ColorByFeatureName"           "ColorByFeatureSource"        
##  [7] "ColorByFeatureDynamicSource"  "ColorBySampleName"           
##  [9] "ColorBySampleSource"          "ColorBySampleDynamicSource"  
## [11] "ShapeBy"                      "SizeBy"                      
## [13] "SelectionEffect"              "SelectionColor"              
## [15] "SelectionAlpha"               "ZoomData"                    
## [17] "BrushData"                    "VisualBoxOpen"               
## [19] "VisualChoices"                "ContourAdd"                  
## [21] "ContourColor"                 "PointSize"                   
## [23] "PointAlpha"                   "Downsample"                  
## [25] "DownsampleResolution"         "FontSize"                    
## [27] "LegendPosition"               "PanelId"                     
## [29] "PanelHeight"                  "PanelWidth"                  
## [31] "SelectionBoxOpen"             "RowSelectionSource"          
## [33] "ColumnSelectionSource"        "DataBoxOpen"                 
## [35] "RowSelectionDynamicSource"    "RowSelectionType"            
## [37] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [39] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [41] "SelectionHistory"
\end{verbatim}

\hypertarget{columndotplot}{%
\subsection{\texorpdfstring{\texttt{ColumnDotPlot}}{ColumnDotPlot}}\label{columndotplot}}

The \href{https://isee.github.io/iSEE/reference/ColumnDotPlot-class.html}{\texttt{ColumnDotPlot}} class inherits from the \texttt{DotPlot} class and represents all per-column dot plots.
This refers to all plots where each column is represented by no more than one dot/point on the plot.
It provides functionality to manage \texttt{colData} fields for modifying the plot aesthetics.
It is also restricted to receiving and transmitting column identities in single and multiple selections.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"ColumnDotPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "ColorByColumnData"            "ColorByFeatureNameAssay"     
##  [3] "ColorBySampleNameColor"       "ShapeByColumnData"           
##  [5] "SizeByColumnData"             "FacetByRow"                  
##  [7] "FacetByColumn"                "ColorBy"                     
##  [9] "ColorByDefaultColor"          "ColorByFeatureName"          
## [11] "ColorByFeatureSource"         "ColorByFeatureDynamicSource" 
## [13] "ColorBySampleName"            "ColorBySampleSource"         
## [15] "ColorBySampleDynamicSource"   "ShapeBy"                     
## [17] "SizeBy"                       "SelectionEffect"             
## [19] "SelectionColor"               "SelectionAlpha"              
## [21] "ZoomData"                     "BrushData"                   
## [23] "VisualBoxOpen"                "VisualChoices"               
## [25] "ContourAdd"                   "ContourColor"                
## [27] "PointSize"                    "PointAlpha"                  
## [29] "Downsample"                   "DownsampleResolution"        
## [31] "FontSize"                     "LegendPosition"              
## [33] "PanelId"                      "PanelHeight"                 
## [35] "PanelWidth"                   "SelectionBoxOpen"            
## [37] "RowSelectionSource"           "ColumnSelectionSource"       
## [39] "DataBoxOpen"                  "RowSelectionDynamicSource"   
## [41] "RowSelectionType"             "RowSelectionSaved"           
## [43] "ColumnSelectionDynamicSource" "ColumnSelectionType"         
## [45] "ColumnSelectionSaved"         "SelectionHistory"
\end{verbatim}

\hypertarget{rowdotplot}{%
\subsection{\texorpdfstring{\texttt{RowDotPlot}}{RowDotPlot}}\label{rowdotplot}}

The \href{https://isee.github.io/iSEE/reference/RowDotPlot-class.html}{\texttt{RowDotPlot}} class inherits from the \texttt{DotPlot} class and represents all per-row dot plots.
This refers to all plots where each row is represented by no more than one dot/point on the plot.
It provides functionality to manage \texttt{rowData} fields for modifying the plot aesthetics.
It is also restricted to receiving and transmitting row identities in single and multiple selections.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"RowDotPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "ColorByRowData"               "ColorBySampleNameAssay"      
##  [3] "ColorByFeatureNameColor"      "ShapeByRowData"              
##  [5] "SizeByRowData"                "FacetByRow"                  
##  [7] "FacetByColumn"                "ColorBy"                     
##  [9] "ColorByDefaultColor"          "ColorByFeatureName"          
## [11] "ColorByFeatureSource"         "ColorByFeatureDynamicSource" 
## [13] "ColorBySampleName"            "ColorBySampleSource"         
## [15] "ColorBySampleDynamicSource"   "ShapeBy"                     
## [17] "SizeBy"                       "SelectionEffect"             
## [19] "SelectionColor"               "SelectionAlpha"              
## [21] "ZoomData"                     "BrushData"                   
## [23] "VisualBoxOpen"                "VisualChoices"               
## [25] "ContourAdd"                   "ContourColor"                
## [27] "PointSize"                    "PointAlpha"                  
## [29] "Downsample"                   "DownsampleResolution"        
## [31] "FontSize"                     "LegendPosition"              
## [33] "PanelId"                      "PanelHeight"                 
## [35] "PanelWidth"                   "SelectionBoxOpen"            
## [37] "RowSelectionSource"           "ColumnSelectionSource"       
## [39] "DataBoxOpen"                  "RowSelectionDynamicSource"   
## [41] "RowSelectionType"             "RowSelectionSaved"           
## [43] "ColumnSelectionDynamicSource" "ColumnSelectionType"         
## [45] "ColumnSelectionSaved"         "SelectionHistory"
\end{verbatim}

\hypertarget{table}{%
\subsection{\texorpdfstring{\texttt{Table}}{Table}}\label{table}}

The \href{https://isee.github.io/iSEE/reference/Table-class.html}{\texttt{Table}} class inherits from the \texttt{Panel} class and represents all tables rendered using \emph{\href{https://CRAN.R-project.org/package=DT}{DT}}.
Each row of the table is expected to correspond to a row or column of the \texttt{SummarizedExperiment}.
This class provides functionality to render the \texttt{DT::datatable} widget, monitor single selections and apply search filters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"Table"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Selected"                     "Search"                      
##  [3] "SearchColumns"                "PanelId"                     
##  [5] "PanelHeight"                  "PanelWidth"                  
##  [7] "SelectionBoxOpen"             "RowSelectionSource"          
##  [9] "ColumnSelectionSource"        "DataBoxOpen"                 
## [11] "RowSelectionDynamicSource"    "RowSelectionType"            
## [13] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [15] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [17] "SelectionHistory"
\end{verbatim}

\hypertarget{columntable}{%
\subsection{\texorpdfstring{\texttt{ColumnTable}}{ColumnTable}}\label{columntable}}

The \href{https://isee.github.io/iSEE/reference/ColumnTable-class.html}{\texttt{ColumnTable}} class inherits from the \texttt{Table} class and represents all tables where the rows correspond to columns of the \texttt{SummarizedExperiment}.
Instances of this class can only transmit single and multiple selections on columns.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"ColumnTable"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Selected"                     "Search"                      
##  [3] "SearchColumns"                "PanelId"                     
##  [5] "PanelHeight"                  "PanelWidth"                  
##  [7] "SelectionBoxOpen"             "RowSelectionSource"          
##  [9] "ColumnSelectionSource"        "DataBoxOpen"                 
## [11] "RowSelectionDynamicSource"    "RowSelectionType"            
## [13] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [15] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [17] "SelectionHistory"
\end{verbatim}

\hypertarget{rowtable}{%
\subsection{\texorpdfstring{\texttt{RowTable}}{RowTable}}\label{rowtable}}

The \href{https://isee.github.io/iSEE/reference/RowTable-class.html}{\texttt{RowTable}} class inherits from the \texttt{Table} class and represents all tables where the rows correspond to rows of the \texttt{SummarizedExperiment}.
Instances of this class can only transmit single and multiple selections on rows.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"RowTable"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Selected"                     "Search"                      
##  [3] "SearchColumns"                "PanelId"                     
##  [5] "PanelHeight"                  "PanelWidth"                  
##  [7] "SelectionBoxOpen"             "RowSelectionSource"          
##  [9] "ColumnSelectionSource"        "DataBoxOpen"                 
## [11] "RowSelectionDynamicSource"    "RowSelectionType"            
## [13] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [15] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [17] "SelectionHistory"
\end{verbatim}

\hypertarget{concrete-classes}{%
\section{Concrete classes}\label{concrete-classes}}

\hypertarget{reduceddimensionplot}{%
\subsection{\texorpdfstring{\texttt{ReducedDimensionPlot}}{ReducedDimensionPlot}}\label{reduceddimensionplot}}

The \href{https://isee.github.io/iSEE/reference/ReducedDimensionPlot-class.html}{\texttt{ReducedDimensionPlot}} class inherits from the \texttt{ColumnDotPlot} class and plots reduced dimension coordinates from an entry of the \texttt{reducedDims} in a \texttt{SingleCellExperiment}.
It provides functionality to choose the result and extract the relevant entry in preparation for plotting.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"ReducedDimensionPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Type"                         "XAxis"                       
##  [3] "YAxis"                        "ColorByColumnData"           
##  [5] "ColorByFeatureNameAssay"      "ColorBySampleNameColor"      
##  [7] "ShapeByColumnData"            "SizeByColumnData"            
##  [9] "FacetByRow"                   "FacetByColumn"               
## [11] "ColorBy"                      "ColorByDefaultColor"         
## [13] "ColorByFeatureName"           "ColorByFeatureSource"        
## [15] "ColorByFeatureDynamicSource"  "ColorBySampleName"           
## [17] "ColorBySampleSource"          "ColorBySampleDynamicSource"  
## [19] "ShapeBy"                      "SizeBy"                      
## [21] "SelectionEffect"              "SelectionColor"              
## [23] "SelectionAlpha"               "ZoomData"                    
## [25] "BrushData"                    "VisualBoxOpen"               
## [27] "VisualChoices"                "ContourAdd"                  
## [29] "ContourColor"                 "PointSize"                   
## [31] "PointAlpha"                   "Downsample"                  
## [33] "DownsampleResolution"         "FontSize"                    
## [35] "LegendPosition"               "PanelId"                     
## [37] "PanelHeight"                  "PanelWidth"                  
## [39] "SelectionBoxOpen"             "RowSelectionSource"          
## [41] "ColumnSelectionSource"        "DataBoxOpen"                 
## [43] "RowSelectionDynamicSource"    "RowSelectionType"            
## [45] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [47] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [49] "SelectionHistory"
\end{verbatim}

\hypertarget{featureassayplot}{%
\subsection{\texorpdfstring{\texttt{FeatureAssayPlot}}{FeatureAssayPlot}}\label{featureassayplot}}

The \href{https://isee.github.io/iSEE/reference/FeatureAssayPlot-class.html}{\texttt{FeatureAssayPlot}} class inherits from the \texttt{ColumnDotPlot} class and plots the assay values for a feature across all samples, using an entry of the \texttt{assays()} from any \texttt{SummarizedExperiment} object.
It provides functionality to choose the feature of interest and any associated variable to plot on the x-axis, as well as a method to extract the relevant pieces of data in preparation for plotting.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"FeatureAssayPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Assay"                        "XAxis"                       
##  [3] "XAxisColumnData"              "XAxisFeatureName"            
##  [5] "XAxisFeatureSource"           "XAxisFeatureDynamicSource"   
##  [7] "YAxisFeatureName"             "YAxisFeatureSource"          
##  [9] "YAxisFeatureDynamicSource"    "ColorByColumnData"           
## [11] "ColorByFeatureNameAssay"      "ColorBySampleNameColor"      
## [13] "ShapeByColumnData"            "SizeByColumnData"            
## [15] "FacetByRow"                   "FacetByColumn"               
## [17] "ColorBy"                      "ColorByDefaultColor"         
## [19] "ColorByFeatureName"           "ColorByFeatureSource"        
## [21] "ColorByFeatureDynamicSource"  "ColorBySampleName"           
## [23] "ColorBySampleSource"          "ColorBySampleDynamicSource"  
## [25] "ShapeBy"                      "SizeBy"                      
## [27] "SelectionEffect"              "SelectionColor"              
## [29] "SelectionAlpha"               "ZoomData"                    
## [31] "BrushData"                    "VisualBoxOpen"               
## [33] "VisualChoices"                "ContourAdd"                  
## [35] "ContourColor"                 "PointSize"                   
## [37] "PointAlpha"                   "Downsample"                  
## [39] "DownsampleResolution"         "FontSize"                    
## [41] "LegendPosition"               "PanelId"                     
## [43] "PanelHeight"                  "PanelWidth"                  
## [45] "SelectionBoxOpen"             "RowSelectionSource"          
## [47] "ColumnSelectionSource"        "DataBoxOpen"                 
## [49] "RowSelectionDynamicSource"    "RowSelectionType"            
## [51] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [53] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [55] "SelectionHistory"
\end{verbatim}

\hypertarget{columndataplot}{%
\subsection{\texorpdfstring{\texttt{ColumnDataPlot}}{ColumnDataPlot}}\label{columndataplot}}

The \href{https://isee.github.io/iSEE/reference/ColumnDataPlot-class.html}{\texttt{ColumnDataPlot}} class inherits from the \texttt{ColumnDotPlot} class and plots \texttt{colData} variables by themselves or against each other.
It provides functionality to choose and extract the variables to plot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"ColumnDataPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "XAxis"                        "YAxis"                       
##  [3] "XAxisColumnData"              "ColorByColumnData"           
##  [5] "ColorByFeatureNameAssay"      "ColorBySampleNameColor"      
##  [7] "ShapeByColumnData"            "SizeByColumnData"            
##  [9] "FacetByRow"                   "FacetByColumn"               
## [11] "ColorBy"                      "ColorByDefaultColor"         
## [13] "ColorByFeatureName"           "ColorByFeatureSource"        
## [15] "ColorByFeatureDynamicSource"  "ColorBySampleName"           
## [17] "ColorBySampleSource"          "ColorBySampleDynamicSource"  
## [19] "ShapeBy"                      "SizeBy"                      
## [21] "SelectionEffect"              "SelectionColor"              
## [23] "SelectionAlpha"               "ZoomData"                    
## [25] "BrushData"                    "VisualBoxOpen"               
## [27] "VisualChoices"                "ContourAdd"                  
## [29] "ContourColor"                 "PointSize"                   
## [31] "PointAlpha"                   "Downsample"                  
## [33] "DownsampleResolution"         "FontSize"                    
## [35] "LegendPosition"               "PanelId"                     
## [37] "PanelHeight"                  "PanelWidth"                  
## [39] "SelectionBoxOpen"             "RowSelectionSource"          
## [41] "ColumnSelectionSource"        "DataBoxOpen"                 
## [43] "RowSelectionDynamicSource"    "RowSelectionType"            
## [45] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [47] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [49] "SelectionHistory"
\end{verbatim}

\hypertarget{sampleassayplot}{%
\subsection{\texorpdfstring{\texttt{SampleAssayPlot}}{SampleAssayPlot}}\label{sampleassayplot}}

The \href{https://isee.github.io/iSEE/reference/SampleAssayPlot-class.html}{\texttt{SampleAssayPlot}} class inherits from the \texttt{RowDotPlot} class and plots the assay values for a sample across all features, using an entry of the \texttt{assays()} from any \texttt{SummarizedExperiment} object.
It provides functionality to choose the sample of interest and any associated variable to plot on the x-axis, as well as a method to extract the relevant pieces of data in preparation for plotting.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"FeatureAssayPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Assay"                        "XAxis"                       
##  [3] "XAxisColumnData"              "XAxisFeatureName"            
##  [5] "XAxisFeatureSource"           "XAxisFeatureDynamicSource"   
##  [7] "YAxisFeatureName"             "YAxisFeatureSource"          
##  [9] "YAxisFeatureDynamicSource"    "ColorByColumnData"           
## [11] "ColorByFeatureNameAssay"      "ColorBySampleNameColor"      
## [13] "ShapeByColumnData"            "SizeByColumnData"            
## [15] "FacetByRow"                   "FacetByColumn"               
## [17] "ColorBy"                      "ColorByDefaultColor"         
## [19] "ColorByFeatureName"           "ColorByFeatureSource"        
## [21] "ColorByFeatureDynamicSource"  "ColorBySampleName"           
## [23] "ColorBySampleSource"          "ColorBySampleDynamicSource"  
## [25] "ShapeBy"                      "SizeBy"                      
## [27] "SelectionEffect"              "SelectionColor"              
## [29] "SelectionAlpha"               "ZoomData"                    
## [31] "BrushData"                    "VisualBoxOpen"               
## [33] "VisualChoices"                "ContourAdd"                  
## [35] "ContourColor"                 "PointSize"                   
## [37] "PointAlpha"                   "Downsample"                  
## [39] "DownsampleResolution"         "FontSize"                    
## [41] "LegendPosition"               "PanelId"                     
## [43] "PanelHeight"                  "PanelWidth"                  
## [45] "SelectionBoxOpen"             "RowSelectionSource"          
## [47] "ColumnSelectionSource"        "DataBoxOpen"                 
## [49] "RowSelectionDynamicSource"    "RowSelectionType"            
## [51] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [53] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [55] "SelectionHistory"
\end{verbatim}

\hypertarget{rowdataplot}{%
\subsection{\texorpdfstring{\texttt{RowDataPlot}}{RowDataPlot}}\label{rowdataplot}}

The \href{https://isee.github.io/iSEE/reference/RowDataPlot-class.html}{\texttt{RowDataPlot}} class inherits from the \texttt{RowDotPlot} class and plots \texttt{rowData} variables by themselves or against each other.
It provides functionality to choose and extract the variables to plot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"RowDataPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "XAxis"                        "YAxis"                       
##  [3] "XAxisRowData"                 "ColorByRowData"              
##  [5] "ColorBySampleNameAssay"       "ColorByFeatureNameColor"     
##  [7] "ShapeByRowData"               "SizeByRowData"               
##  [9] "FacetByRow"                   "FacetByColumn"               
## [11] "ColorBy"                      "ColorByDefaultColor"         
## [13] "ColorByFeatureName"           "ColorByFeatureSource"        
## [15] "ColorByFeatureDynamicSource"  "ColorBySampleName"           
## [17] "ColorBySampleSource"          "ColorBySampleDynamicSource"  
## [19] "ShapeBy"                      "SizeBy"                      
## [21] "SelectionEffect"              "SelectionColor"              
## [23] "SelectionAlpha"               "ZoomData"                    
## [25] "BrushData"                    "VisualBoxOpen"               
## [27] "VisualChoices"                "ContourAdd"                  
## [29] "ContourColor"                 "PointSize"                   
## [31] "PointAlpha"                   "Downsample"                  
## [33] "DownsampleResolution"         "FontSize"                    
## [35] "LegendPosition"               "PanelId"                     
## [37] "PanelHeight"                  "PanelWidth"                  
## [39] "SelectionBoxOpen"             "RowSelectionSource"          
## [41] "ColumnSelectionSource"        "DataBoxOpen"                 
## [43] "RowSelectionDynamicSource"    "RowSelectionType"            
## [45] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [47] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [49] "SelectionHistory"
\end{verbatim}

\hypertarget{columndatatable}{%
\subsection{\texorpdfstring{\texttt{ColumnDataTable}}{ColumnDataTable}}\label{columndatatable}}

The \href{https://isee.github.io/iSEE/reference/ColumnDataTable-class.html}{\texttt{ColumnDataTable}} class inherits from the \texttt{ColumnTable} class and shows the contents of the \texttt{colData} in a table.
It provides functionality to extract the \texttt{colData} in preparation for rendering.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"ColumnDataTable"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Selected"                     "Search"                      
##  [3] "SearchColumns"                "PanelId"                     
##  [5] "PanelHeight"                  "PanelWidth"                  
##  [7] "SelectionBoxOpen"             "RowSelectionSource"          
##  [9] "ColumnSelectionSource"        "DataBoxOpen"                 
## [11] "RowSelectionDynamicSource"    "RowSelectionType"            
## [13] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [15] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [17] "SelectionHistory"
\end{verbatim}

\hypertarget{rowdatatable}{%
\subsection{\texorpdfstring{\texttt{RowDataTable}}{RowDataTable}}\label{rowdatatable}}

The \href{https://isee.github.io/iSEE/reference/RowDataTable-class.html}{\texttt{RowDataTable}} class inherits from the \texttt{RowTable} class and shows the contents of the \texttt{rowData} in a table.
It provides functionality to extract the \texttt{rowData} in preparation for rendering.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"RowDataTable"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Selected"                     "Search"                      
##  [3] "SearchColumns"                "PanelId"                     
##  [5] "PanelHeight"                  "PanelWidth"                  
##  [7] "SelectionBoxOpen"             "RowSelectionSource"          
##  [9] "ColumnSelectionSource"        "DataBoxOpen"                 
## [11] "RowSelectionDynamicSource"    "RowSelectionType"            
## [13] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [15] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [17] "SelectionHistory"
\end{verbatim}

\hypertarget{complexheatmapplot}{%
\subsection{\texorpdfstring{\texttt{ComplexHeatmapPlot}}{ComplexHeatmapPlot}}\label{complexheatmapplot}}

The \href{https://isee.github.io/iSEE/reference/ComplexHeatmapPlot-class.html}{\texttt{ComplexHeatmapPlot}} class inherits from the \texttt{Panel} class and creates a heatmap from assay values using the \emph{\href{https://bioconductor.org/packages/3.11/ComplexHeatmap}{ComplexHeatmap}} package.
It provides functionality to specify the features to be shown, which assay to show, transformations to be applied, and which metadata variables to display as row and column heatmap annotations.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slotNames}\NormalTok{(}\KeywordTok{getClass}\NormalTok{(}\StringTok{"ComplexHeatmapPlot"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Assay"                        "CustomRows"                  
##  [3] "CustomRowsText"               "ClusterRows"                 
##  [5] "ClusterRowsDistance"          "ClusterRowsMethod"           
##  [7] "DataBoxOpen"                  "VisualChoices"               
##  [9] "ColumnData"                   "RowData"                     
## [11] "CustomBounds"                 "LowerBound"                  
## [13] "UpperBound"                   "AssayCenterRows"             
## [15] "AssayScaleRows"               "DivergentColormap"           
## [17] "ShowDimNames"                 "LegendPosition"              
## [19] "LegendDirection"              "VisualBoxOpen"               
## [21] "SelectionEffect"              "SelectionColor"              
## [23] "PanelId"                      "PanelHeight"                 
## [25] "PanelWidth"                   "SelectionBoxOpen"            
## [27] "RowSelectionSource"           "ColumnSelectionSource"       
## [29] "RowSelectionDynamicSource"    "RowSelectionType"            
## [31] "RowSelectionSaved"            "ColumnSelectionDynamicSource"
## [33] "ColumnSelectionType"          "ColumnSelectionSaved"        
## [35] "SelectionHistory"
\end{verbatim}

\hypertarget{api}{%
\chapter{Panel generics}\label{api}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

This chapter lists of all generics provided by \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} to implement class-specific behaviors.
For each generic, we will show its signature and all available methods implemented for subclasses.
Do not be intimidated; it is rare that it is necessary to define methods for all of the generics shown here.
If your class inherits from an existing \texttt{Panel} subclass, many of these methods will be implemented for free, and all you have to do is to override a handful of methods to achieve the desired customization.
We recommend skimming over this chapter on the first read to get a feel for the available entry points into the \texttt{Panel} API.
Once you have a better idea of what your class needs to do, you can obtain exhaustive documentation about each generic in the usual way, e.g., \texttt{?.defineInterface}.

\hypertarget{parameter-set-up}{%
\section{Parameter set-up}\label{parameter-set-up}}

\href{https://isee.github.io/iSEE/reference/setup-generics.html}{\texttt{.cacheCommonInfo()}} caches common values to be used for all instances of a particular panel class.
These cached values can be used to, e.g., populate the UI or set up constants to be used in the panel's output.
This avoids potentially costly re-calculations throughout the lifetime of the \texttt{iSEE()} application.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".cacheCommonInfo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".cacheCommonInfo" defined from package "iSEE"
## 
## function (x, se) 
## standardGeneric(".cacheCommonInfo")
## <bytecode: 0x7f9f596a6d88>
## <environment: 0x7f9f596c4848>
## Methods may be defined for arguments: x, se
## Use  showMethods(".cacheCommonInfo")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".cacheCommonInfo"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .cacheCommonInfo (package iSEE)
## x="ColumnDataTable"
## x="ColumnDotPlot"
## x="ComplexHeatmapPlot"
## x="DotPlot"
## x="Panel"
## x="ReducedDimensionPlot"
## x="RowDataTable"
## x="RowDotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/setup-generics.html}{\texttt{.refineParameters()}} edits the parameters of a panel to ensure that they are valid.
For example, we may need to restrict the choices of a selectize element to some pre-defined possibilities.
This is run for each panel during the \texttt{iSEE()} application set-up to validate the user-supplied panel configuration.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".refineParameters"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".refineParameters" defined from package "iSEE"
## 
## function (x, se) 
## standardGeneric(".refineParameters")
## <bytecode: 0x7f9f44452b50>
## <environment: 0x7f9f444968d0>
## Methods may be defined for arguments: x, se
## Use  showMethods(".refineParameters")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".refineParameters"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .refineParameters (package iSEE)
## x="ColumnDataPlot"
## x="ColumnDataTable"
## x="ColumnDotPlot"
## x="ColumnTable"
## x="ComplexHeatmapPlot"
## x="DotPlot"
## x="FeatureAssayPlot"
## x="Panel"
## x="ReducedDimensionPlot"
## x="RowDataPlot"
## x="RowDataTable"
## x="RowDotPlot"
## x="RowTable"
## x="SampleAssayPlot"
\end{verbatim}

\hypertarget{defining-the-user-interface}{%
\section{Defining the user interface}\label{defining-the-user-interface}}

\hypertarget{in-general}{%
\subsection{In general}\label{in-general}}

\href{https://isee.github.io/iSEE/reference/interface-generics.html}{\texttt{.defineInterface()}} defines the user interface (UI) for a panel, defining all HTML widgets required to modify parameters.
Parameters should be bundled into collapsible boxes according to their approximate purpose.
This generic provides the most general mechanism for controlling the panel's interface.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".defineInterface" defined from package "iSEE"
## 
## function (x, se, select_info) 
## standardGeneric(".defineInterface")
## <bytecode: 0x7f9f56a22758>
## <environment: 0x7f9f594f3c90>
## Methods may be defined for arguments: x, se, select_info
## Use  showMethods(".defineInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineInterface (package iSEE)
## x="ColumnDotPlot"
## x="ComplexHeatmapPlot"
## x="Panel"
## x="RowDotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/interface-generics.html}{\texttt{.defineDataInterface()}} defines the UI for modifying all data-related parameters in a given panel.
Such parameters are fundamental to the interpretation of the panel's output, as opposed to their aesthetic counterparts.
This generic allows developers to fine-tune the data UI for subclasses without reimplementing the parent class' \texttt{.defineInterface()}, especially if we wish to re-use the parent's UI for aesthetic parameters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineDataInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".defineDataInterface" defined from package "iSEE"
## 
## function (x, se, select_info) 
## standardGeneric(".defineDataInterface")
## <bytecode: 0x7f9f59533f30>
## <environment: 0x7f9f59563718>
## Methods may be defined for arguments: x, se, select_info
## Use  showMethods(".defineDataInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineDataInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineDataInterface (package iSEE)
## x="ColumnDataPlot"
## x="ComplexHeatmapPlot"
## x="FeatureAssayPlot"
## x="Panel"
## x="ReducedDimensionPlot"
## x="RowDataPlot"
## x="SampleAssayPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/interface-generics.html}{\texttt{.hideInterface()}} determines whether certain UI elements should be hidden from the user.
This allows subclasses to hide easily inappropriate or irrelevant parts of the parent's UI without redefining \texttt{.defineInterface()}.
For example, we can remove row selection UI elements for panels that only accept column selections.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".hideInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".hideInterface" defined from package "iSEE"
## 
## function (x, field) 
## standardGeneric(".hideInterface")
## <bytecode: 0x7f9f44628000>
## <environment: 0x7f9f44637d30>
## Methods may be defined for arguments: x, field
## Use  showMethods(".hideInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".hideInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .hideInterface (package iSEE)
## x="ColumnDataTable"
## x="ColumnDotPlot"
## x="ColumnTable"
## x="ComplexHeatmapPlot"
## x="Panel"
## x="RowDataTable"
## x="RowDotPlot"
## x="RowTable"
## x="Table"
\end{verbatim}

\hypertarget{the-dotplot-visual-interface}{%
\subsection{\texorpdfstring{The \texttt{DotPlot} visual interface}{The DotPlot visual interface}}\label{the-dotplot-visual-interface}}

\href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualColorInterface()}} defines the UI for color-related visual parameters in a \texttt{DotPlot} subclass.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineVisualColorInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".defineVisualColorInterface" defined from package "iSEE"
## 
## function (x, se, select_info) 
## standardGeneric(".defineVisualColorInterface")
## <bytecode: 0x7f9f451c5798>
## <environment: 0x7f9f56b024e8>
## Methods may be defined for arguments: x, se, select_info
## Use  showMethods(".defineVisualColorInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineVisualColorInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineVisualColorInterface (package iSEE)
## x="ColumnDotPlot"
## x="RowDotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualFacetInterface()}} defines the UI for facet-related visual parameters in a \texttt{DotPlot} subclass.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineVisualFacetInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".defineVisualFacetInterface" defined from package "iSEE"
## 
## function (x, se) 
## standardGeneric(".defineVisualFacetInterface")
## <bytecode: 0x7f9f45194568>
## <environment: 0x7f9f4519a0c8>
## Methods may be defined for arguments: x, se
## Use  showMethods(".defineVisualFacetInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineVisualFacetInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineVisualFacetInterface (package iSEE)
## x="ColumnDotPlot"
## x="RowDotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualShapeInterface()}} defines the UI for shape-related visual parameters in a \texttt{DotPlot} subclass.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineVisualShapeInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".defineVisualShapeInterface" defined from package "iSEE"
## 
## function (x, se) 
## standardGeneric(".defineVisualShapeInterface")
## <bytecode: 0x7f9f451253e0>
## <environment: 0x7f9f4512fc40>
## Methods may be defined for arguments: x, se
## Use  showMethods(".defineVisualShapeInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineVisualShapeInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineVisualShapeInterface (package iSEE)
## x="ColumnDotPlot"
## x="RowDotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualSizeInterface()}} defines the UI for size-related visual parameters in a \texttt{DotPlot} subclass.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineVisualSizeInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".defineVisualSizeInterface" defined from package "iSEE"
## 
## function (x, se) 
## standardGeneric(".defineVisualSizeInterface")
## <bytecode: 0x7f9f450ead10>
## <environment: 0x7f9f450ff720>
## Methods may be defined for arguments: x, se
## Use  showMethods(".defineVisualSizeInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineVisualSizeInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineVisualSizeInterface (package iSEE)
## x="ColumnDotPlot"
## x="RowDotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualTextInterface()}} defines the UI for text-related visual parameters in a \texttt{DotPlot} subclass.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineVisualTextInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".defineVisualTextInterface" defined from package "iSEE"
## 
## function (x, se) 
## standardGeneric(".defineVisualTextInterface")
## <bytecode: 0x7f9f450c5ce0>
## <environment: 0x7f9f450d2c68>
## Methods may be defined for arguments: x, se
## Use  showMethods(".defineVisualTextInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineVisualTextInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineVisualTextInterface (package iSEE)
## x="DotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/visual-parameters-generics.html}{\texttt{.defineVisualOtherInterface()}} defines the UI for other visual parameters in a \texttt{DotPlot} subclass.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineVisualOtherInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".defineVisualOtherInterface" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".defineVisualOtherInterface")
## <bytecode: 0x7f9f451727f0>
## <environment: 0x7f9f45176320>
## Methods may be defined for arguments: x
## Use  showMethods(".defineVisualOtherInterface")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineVisualOtherInterface"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineVisualOtherInterface (package iSEE)
## x="DotPlot"
\end{verbatim}

These generics allow developers to change UI elements for a subclass without completely reimplementing \texttt{.defineInterface()}.
Of course, if we have already specialized \texttt{.defineInterface()}, then there's no need to define methods for these generics.

\hypertarget{creating-observers}{%
\section{Creating observers}\label{creating-observers}}

\href{https://isee.github.io/iSEE/reference/observer-generics.html}{\texttt{.createObservers()}} sets up Shiny observers for the current session.
This is the workhorse function to ensure that the panel actually responds to user input.
Developers can define arbitrarily complex observer logic here as long as it is self-contained within a single panel.
(Interactive mechanics that involve communication between panels is handled elsewhere.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## nonstandardGenericFunction for ".createObservers" defined from package "iSEE"
## 
## function (x, se, input, session, pObjects, rObjects) 
## {
##     standardGeneric(".createObservers")
## }
## <bytecode: 0x7f9f595c5158>
## <environment: 0x7f9f59603bf8>
## Methods may be defined for arguments: x, se, input, session, pObjects, rObjects
## Use  showMethods(".createObservers")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .createObservers (package iSEE)
## x="ColumnDataPlot"
## x="ColumnDotPlot"
## x="ColumnTable"
## x="ComplexHeatmapPlot"
## x="DotPlot"
## x="FeatureAssayPlot"
## x="Panel"
## x="ReducedDimensionPlot"
## x="RowDataPlot"
## x="RowDotPlot"
## x="RowTable"
## x="SampleAssayPlot"
## x="Table"
\end{verbatim}

\hypertarget{defining-panel-outputs}{%
\section{Defining panel outputs}\label{defining-panel-outputs}}

\hypertarget{in-general-1}{%
\subsection{In general}\label{in-general-1}}

\href{https://isee.github.io/iSEE/reference/output-generics.html}{\texttt{.defineOutput()}} defines the interface element containing the visual output of the panel.
Examples include \texttt{plotOutput()} for plots or \texttt{dataTableOutput()} for tables.
Note that this generic only defines the output in the \texttt{iSEE()} interface; it does not control the rendering.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".defineOutput"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## nonstandardGenericFunction for ".defineOutput" defined from package "iSEE"
## 
## function (x, ...) 
## {
##     standardGeneric(".defineOutput")
## }
## <bytecode: 0x7f9f56aec2a8>
## <environment: 0x7f9f56ad6b58>
## Methods may be defined for arguments: x
## Use  showMethods(".defineOutput")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".defineOutput"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .defineOutput (package iSEE)
## x="ComplexHeatmapPlot"
## x="DotPlot"
## x="Table"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/output-generics.html}{\texttt{.renderOutput()}} assigns a reactive expression to populate the output interface element with content.
This is usually as simple as calling functions like \texttt{renderPlotOutput()} with an appropriate rendering expression containing a call to \texttt{.retrieveOutput()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".renderOutput"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## nonstandardGenericFunction for ".renderOutput" defined from package "iSEE"
## 
## function (x, se, ..., output, pObjects, rObjects) 
## {
##     standardGeneric(".renderOutput")
## }
## <bytecode: 0x7f9f443e2278>
## <environment: 0x7f9f443ef788>
## Methods may be defined for arguments: x, se, output, pObjects, rObjects
## Use  showMethods(".renderOutput")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".renderOutput"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .renderOutput (package iSEE)
## x="ComplexHeatmapPlot"
## x="DotPlot"
## x="Panel"
## x="Table"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/output-generics.html}{\texttt{.generateOutput()}} actually generates the panel output, be it a plot or table or something more exotic.
This is usually the real function that does all the work, being called by \texttt{.retrieveOutput()} prior to rendering the output.
Some effort is required here to ensure that the commands used to generate the output are also captured.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".generateOutput"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## nonstandardGenericFunction for ".generateOutput" defined from package "iSEE"
## 
## function (x, se, ..., all_memory, all_contents) 
## {
##     standardGeneric(".generateOutput")
## }
## <bytecode: 0x7f9f446996c8>
## <environment: 0x7f9f446ce070>
## Methods may be defined for arguments: x, se, all_memory, all_contents
## Use  showMethods(".generateOutput")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".generateOutput"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .generateOutput (package iSEE)
## x="ComplexHeatmapPlot"
## x="DotPlot"
## x="Table"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/output-generics.html}{\texttt{.exportOutput()}} converts the panel output into a form that is downloadable, such as a PDF file for plots or CSVs for tables.
This is called whenever the user requests a download of the panel outputs.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".exportOutput"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## nonstandardGenericFunction for ".exportOutput" defined from package "iSEE"
## 
## function (x, se, all_memory, all_contents) 
## {
##     standardGeneric(".exportOutput")
## }
## <bytecode: 0x7f9f450a1370>
## <environment: 0x7f9f450ae8c0>
## Methods may be defined for arguments: x, se, all_memory, all_contents
## Use  showMethods(".exportOutput")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".exportOutput"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .exportOutput (package iSEE)
## x="DotPlot"
## x="Panel"
## x="Table"
\end{verbatim}

\hypertarget{for-dotplots}{%
\subsection{\texorpdfstring{For \texttt{DotPlot}s}{For DotPlots}}\label{for-dotplots}}

\href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.generateDotPlot()}} creates the \texttt{ggplot} object for \texttt{DotPlot} subclasses.
This is called internally by the \texttt{DotPlot} method for \texttt{.generateOutput()} to create the relevant output.
Developers of \texttt{DotPlot} subclasses can specialize this generic to avoid having to reimplement \texttt{.generateOutput()} (and the associated data management therein).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".generateDotPlot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".generateDotPlot" defined from package "iSEE"
## 
## function (x, labels, envir) 
## standardGeneric(".generateDotPlot")
## <bytecode: 0x7f9f4474b9c8>
## <environment: 0x7f9f44757220>
## Methods may be defined for arguments: x, labels, envir
## Use  showMethods(".generateDotPlot")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".generateDotPlot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .generateDotPlot (package iSEE)
## x="DotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.generateDotPlotData()}} creates the \texttt{data.frame} that is used by \texttt{.generateDotPlot()}.
This allows developers to change the data setup for a \texttt{DotPlot} subclass without having to even specialize \texttt{.generateDotPlot()}, provided they are happy with the default \texttt{DotPlot} aesthetics.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".generateDotPlotData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".generateDotPlotData" defined from package "iSEE"
## 
## function (x, envir) 
## standardGeneric(".generateDotPlotData")
## <bytecode: 0x7f9f44707b88>
## <environment: 0x7f9f44730808>
## Methods may be defined for arguments: x, envir
## Use  showMethods(".generateDotPlotData")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".generateDotPlotData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .generateDotPlotData (package iSEE)
## x="ColumnDataPlot"
## x="FeatureAssayPlot"
## x="ReducedDimensionPlot"
## x="RowDataPlot"
## x="SampleAssayPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.prioritizeDotPlotData()}} determines how points should be prioritized during overplotting.
This usually doesn't need to be specialized.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".prioritizeDotPlotData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".prioritizeDotPlotData" defined from package "iSEE"
## 
## function (x, envir) 
## standardGeneric(".prioritizeDotPlotData")
## <bytecode: 0x7f9f444b0d00>
## <environment: 0x7f9f444b48a0>
## Methods may be defined for arguments: x, envir
## Use  showMethods(".prioritizeDotPlotData")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".prioritizeDotPlotData"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .prioritizeDotPlotData (package iSEE)
## x="DotPlot"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.colorByNoneDotPlotField()}} and \href{https://isee.github.io/iSEE/reference/plot-generics.html}{\texttt{.colorByNoneDotPlotScale()}} define the default color scale when \texttt{ColorBy="None"}.
This usually doesn't need to be specialized.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".colorByNoneDotPlotField"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".colorByNoneDotPlotField" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".colorByNoneDotPlotField")
## <bytecode: 0x7f9f5966bae0>
## <environment: 0x7f9f596716b8>
## Methods may be defined for arguments: x
## Use  showMethods(".colorByNoneDotPlotField")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".colorByNoneDotPlotField"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .colorByNoneDotPlotField (package iSEE)
## x="DotPlot"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".colorByNoneDotPlotScale"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".colorByNoneDotPlotScale" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".colorByNoneDotPlotScale")
## <bytecode: 0x7f9f5963d1d8>
## <environment: 0x7f9f5964efe8>
## Methods may be defined for arguments: x
## Use  showMethods(".colorByNoneDotPlotScale")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".colorByNoneDotPlotScale"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .colorByNoneDotPlotScale (package iSEE)
## x="DotPlot"
\end{verbatim}

\hypertarget{for-metadata-dotplots}{%
\subsection{\texorpdfstring{For metadata \texttt{DotPlot}s}{For metadata DotPlots}}\label{for-metadata-dotplots}}

\href{https://isee.github.io/iSEE/reference/metadata-plot-generics.html}{\texttt{.allowableYAxisChoices()}} and \href{https://isee.github.io/iSEE/reference/metadata-plot-generics.html}{\texttt{.allowableXAxisChoices()}} specifies the acceptable fields to put on the x- or y-axes of \texttt{ColumnDataPlot} or \texttt{RowDataPlot} subclasses.
This is typically used to constrain the choices for customized panels that only accept certain column names or types.
For example, a hypothetical MA plot panel would only accept log-fold changes on the y-axis.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".allowableYAxisChoices"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".allowableYAxisChoices" defined from package "iSEE"
## 
## function (x, se) 
## standardGeneric(".allowableYAxisChoices")
## <bytecode: 0x7f9f596e00d8>
## <environment: 0x7f9f596e6a08>
## Methods may be defined for arguments: x, se
## Use  showMethods(".allowableYAxisChoices")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".allowableYAxisChoices"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .allowableYAxisChoices (package iSEE)
## x="ColumnDataPlot"
## x="RowDataPlot"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".allowableXAxisChoices"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".allowableXAxisChoices" defined from package "iSEE"
## 
## function (x, se) 
## standardGeneric(".allowableXAxisChoices")
## <bytecode: 0x7f9f59702260>
## <environment: 0x7f9f59708a40>
## Methods may be defined for arguments: x, se
## Use  showMethods(".allowableXAxisChoices")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".allowableXAxisChoices"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .allowableXAxisChoices (package iSEE)
## x="ColumnDataPlot"
## x="RowDataPlot"
\end{verbatim}

\hypertarget{for-tables}{%
\subsection{\texorpdfstring{For \texttt{Table}s}{For Tables}}\label{for-tables}}

\href{https://isee.github.io/iSEE/reference/table-generics.html}{\texttt{.generateTable()}} creates the \texttt{data.frame} that is rendered into the table widget for \texttt{Table} subclasses.
Each row of the \texttt{data.frame} is generally expected to correspond to a row or column of the dataset.
If this is specialized, there is usually no need to specialize \texttt{.generateOutput()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".generateTable"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".generateTable" defined from package "iSEE"
## 
## function (x, envir) 
## standardGeneric(".generateTable")
## <bytecode: 0x7f9f446580f0>
## <environment: 0x7f9f44663ad0>
## Methods may be defined for arguments: x, envir
## Use  showMethods(".generateTable")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".generateTable"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .generateTable (package iSEE)
## x="ColumnDataTable"
## x="RowDataTable"
\end{verbatim}

\hypertarget{handling-selections}{%
\section{Handling selections}\label{handling-selections}}

\hypertarget{multiple}{%
\subsection{Multiple}\label{multiple}}

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionDimension()}} specifies whether the panel transmits multiple selections along the rows or columns.
It can also be used to indicate that the panel does not transmit anything.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".multiSelectionDimension"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".multiSelectionDimension" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".multiSelectionDimension")
## <bytecode: 0x7f9f44558b18>
## <environment: 0x7f9f4455e530>
## Methods may be defined for arguments: x
## Use  showMethods(".multiSelectionDimension")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".multiSelectionDimension"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .multiSelectionDimension (package iSEE)
## x="ColumnDotPlot"
## x="ColumnTable"
## x="Panel"
## x="RowDotPlot"
## x="RowTable"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionActive()}} returns the parameters that define the ``active'' multiple selection in the current panel.
This is defined as the selection that the user can actively change by interacting with the panel.
(In contrast, the ``saved'' selections are fixed and can only be deleted.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".multiSelectionActive"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".multiSelectionActive" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".multiSelectionActive")
## <bytecode: 0x7f9f445e54f8>
## <environment: 0x7f9f445ee1e0>
## Methods may be defined for arguments: x
## Use  showMethods(".multiSelectionActive")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".multiSelectionActive"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .multiSelectionActive (package iSEE)
## x="DotPlot"
## x="Panel"
## x="Table"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionCommands()}} creates the character vector of row or column names for a multiple selection in the current panel.
More specifically, it returns the commands that will then be evaluated to generate such character vectors.
The identity of the selected rows/columns will ultimately be transmitted to other panels to affect their behavior.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".multiSelectionCommands"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".multiSelectionCommands" defined from package "iSEE"
## 
## function (x, index) 
## standardGeneric(".multiSelectionCommands")
## <bytecode: 0x7f9f4457e378>
## <environment: 0x7f9f445830a8>
## Methods may be defined for arguments: x, index
## Use  showMethods(".multiSelectionCommands")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".multiSelectionCommands"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .multiSelectionCommands (package iSEE)
## x="DotPlot"
## x="Table"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionAvailable()}} reports how many total points are available for selection in the current panel.
This is used for reporting ``percent selected'' statistics below each panel.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".multiSelectionAvailable"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".multiSelectionAvailable" defined from package "iSEE"
## 
## function (x, contents) 
## standardGeneric(".multiSelectionAvailable")
## <bytecode: 0x7f9f445bec90>
## <environment: 0x7f9f445c2670>
## Methods may be defined for arguments: x, contents
## Use  showMethods(".multiSelectionAvailable")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".multiSelectionAvailable"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .multiSelectionAvailable (package iSEE)
## x="Panel"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionClear()}} eliminates the active multiple selection in the current panel.
This is used to wipe selections in response to changes to the plot content that cause those selections to be invalid.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".multiSelectionClear"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".multiSelectionClear" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".multiSelectionClear")
## <bytecode: 0x7f9f445a1cb8>
## <environment: 0x7f9f445a48d0>
## Methods may be defined for arguments: x
## Use  showMethods(".multiSelectionClear")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".multiSelectionClear"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .multiSelectionClear (package iSEE)
## x="DotPlot"
## x="Panel"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionRestricted()}} indicates whether the current panel's data should be restricted to the rows/columns that it receives from an incoming multiple selection.
This is used to determine how changes in the upstream transmitters should propagate through to the current panel's children.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".multiSelectionRestricted"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".multiSelectionRestricted" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".multiSelectionRestricted")
## <bytecode: 0x7f9f4450f0a0>
## <environment: 0x7f9f445154e0>
## Methods may be defined for arguments: x
## Use  showMethods(".multiSelectionRestricted")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".multiSelectionRestricted"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .multiSelectionRestricted (package iSEE)
## x="DotPlot"
## x="Panel"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/multi-select-generics.html}{\texttt{.multiSelectionInvalidated()}} indicates whether the current panel is invalidated when it receives a new multiple selection.
This usually doesn't need to be specialized.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".multiSelectionInvalidated"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".multiSelectionInvalidated" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".multiSelectionInvalidated")
## <bytecode: 0x7f9f4452c628>
## <environment: 0x7f9f44532238>
## Methods may be defined for arguments: x
## Use  showMethods(".multiSelectionInvalidated")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".multiSelectionInvalidated"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .multiSelectionInvalidated (package iSEE)
## x="Panel"
\end{verbatim}

\hypertarget{single}{%
\subsection{Single}\label{single}}

\href{https://isee.github.io/iSEE/reference/single-select-generics.html}{\texttt{.singleSelectionDimension()}} specifies whether the panel transmits single selections of a row or column.
It can also be used to indicate that the panel does not transmit anything.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".singleSelectionDimension"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".singleSelectionDimension" defined from package "iSEE"
## 
## function (x) 
## standardGeneric(".singleSelectionDimension")
## <bytecode: 0x7f9f443b0b48>
## <environment: 0x7f9f443ba438>
## Methods may be defined for arguments: x
## Use  showMethods(".singleSelectionDimension")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".singleSelectionDimension"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .singleSelectionDimension (package iSEE)
## x="ColumnDotPlot"
## x="ColumnTable"
## x="Panel"
## x="RowDotPlot"
## x="RowTable"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/single-select-generics.html}{\texttt{.singleSelectionValue()}} determines the row or column that has been selected in the current panel.
The identity of the row/column is passed onto other panels to affect their behavior.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".singleSelectionValue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".singleSelectionValue" defined from package "iSEE"
## 
## function (x, pObjects) 
## standardGeneric(".singleSelectionValue")
## <bytecode: 0x7f9f44356aa0>
## <environment: 0x7f9f4435e870>
## Methods may be defined for arguments: x, pObjects
## Use  showMethods(".singleSelectionValue")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".singleSelectionValue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .singleSelectionValue (package iSEE)
## x="DotPlot"
## x="Table"
\end{verbatim}

\href{https://isee.github.io/iSEE/reference/single-select-generics.html}{\texttt{.singleSelectionSlots()}} determines how the current panel should respond to single selections from other panels.
This will also automatically set up some of the more difficult observers if sufficient information is supplied by the class.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getGeneric}\NormalTok{(}\StringTok{".singleSelectionValue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## standardGeneric for ".singleSelectionValue" defined from package "iSEE"
## 
## function (x, pObjects) 
## standardGeneric(".singleSelectionValue")
## <bytecode: 0x7f9f44356aa0>
## <environment: 0x7f9f4435e870>
## Methods may be defined for arguments: x, pObjects
## Use  showMethods(".singleSelectionValue")  for currently available ones.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{".singleSelectionValue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Function: .singleSelectionValue (package iSEE)
## x="DotPlot"
## x="Table"
\end{verbatim}

\hypertarget{server}{%
\chapter{Application state}\label{server}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

\emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} uses global variables to keep track of the application state and to trigger reactive expressions.
These are passed in the ubiquitous \texttt{pObjects} and \texttt{rObjects} arguments for non-reactive and reactive variables, respectively.
Both of these objects have pass-by-reference semantics, meaning that any modifications to their contents within functions will persist outside of the function scope.
Of particular relevance is the application memory in \texttt{pObjects}, which panels are expected to read and modify to respond to user interaction and generate output.
Developers should also refrain from adding their own application-wide reactive variables, and should only modify the existing ones through a dedicated set of functions provided by \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}}.
Respecting this paradigm will ensure that custom panels behave correctly in the context of the entire application.

\hypertarget{updating-parameters}{%
\section{Updating parameters}\label{updating-parameters}}

The application memory is a list of \texttt{Panel} instances in \texttt{pObjects\$memory} that captures the current state of the \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} application.
Conceptually, one should be able to extract this list from a running application, pass it to the \texttt{initial=} argument of the \texttt{iSEE()} function and expect to recover the same state.
All modifications to the state should be recorded in the memory, meaning that observer expressions will commonly contain code like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[param_name]] <-}\StringTok{ }\NormalTok{new_value}
\end{Highlighting}
\end{Shaded}

By itself, modifying the application memory will not trigger any further actions.
The memory is too complex to be treated as a reactive value as it would affect too many downstream observers.
Instead, we provide the \texttt{.requestUpdate()} function to indicate to the application that a particular panel needs to be updated.
This sets a flag in \texttt{rObjects} that will eventually trigger re-rendering of the specified panel.

The \texttt{.requestCleanUpdate()} function provides a variant of this approach where the panel should be updated \emph{and} any active or saved multiple selections should be wiped.
This is useful for dealing with changes to ``protected'' parameters that modify the panel contents such that any selection parameters are no longer relevant (e.g., invalidating brushes when the plot coordinates change).
Yet another variant is the \texttt{.requestActiveSelectionUpdate()} function, which indicates whether a panel's active multiple selection has changed; this should be used in the observer expression that responds to the panel's multiple selection mechanism.

The two-step process of memory modification and calling \texttt{.requestUpdate()} is facilitated by functions like \texttt{.createUnprotectedParameterObservers()}, which sets up simple observers for parameter modifications.
However, more complex observers will have to do this manually.

\hypertarget{using-the-memory}{%
\section{Using the memory}\label{using-the-memory}}

In a similar vein, expressions to render output should \emph{never} touch the Shiny \texttt{input} object directly.
(Indeed, \texttt{.renderOutput()} does not even have access to the \texttt{input}.)
As all parameter changes pass through the memory, the updated values of each parameter should also be retrieved from memory.
This involves extracting the desired \texttt{Panel} from \texttt{pObjects\$memory} in methods for generics like \texttt{.createObservers()} that rely on pass-by-reference semantics for correct evaluation of reactive expressions.
Other generics that are not setting up reactive expressions can directly extract values from the supplied \texttt{Panel} object.

Each \texttt{Panel} object can be treated as a list of panel parameters.
Retrieving values is as simple as using the \texttt{{[}{[}} operator with the name of the parameter.
Direct slot access should be avoided, consistent with best practice for S4 programming.

\hypertarget{responding-to-events}{%
\section{Responding to events}\label{responding-to-events}}

Developers can respond to events by calling functions like \texttt{.trackUpdate()} within an observer or rendering expression.
For example, \texttt{.trackUpdate()} will trigger re-evaluation of its context if the panel is updated by \texttt{.requestUpdate()}.
Other variants like \texttt{.trackMultiSelection()} will trigger re-evaluation upon changes to the panel's multiple selections.
This is mostly intended for panels that need to synchronize updates to multiple output elements.
Developers should only use these functions to track updates to the same panel for which the observer/rendering expression is written; management of communication across panels is outside of the scope of these expressions.

\hypertarget{part-worked-examples}{%
\part{Worked examples}\label{part-worked-examples}}

\hypertarget{developing}{%
\chapter{Reduced dimension hexbin plot}\label{developing}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

In this example, we will create a panel class to show dimensionality reduction results using a hexbin plot.
The idea is to improve plotting speed for large datasets by binning points rather than showing each point individually.
Astute readers will note that the proposed class is the same as the \texttt{ReducedDimensionHexPlot} from \emph{\href{https://bioconductor.org/packages/3.11/iSEEu}{iSEEu}}.
This chapter will describe the most relevant aspects of the development process to create a reasonably functional class.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

The choice of a parent class depends on the properties that we want that new panel class to start with.
In this case, to create a panel that inherits all the functionality of the \texttt{ReducedDimensionPlot} panel type, we simply define a new class that extends that class.
We will call the new class \texttt{RedDimHexPlot}, adding an extra parameter to control the resolution of the hexbins.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"RedDimHexPlot"}\NormalTok{, }\DataTypeTok{contains=}\StringTok{"ReducedDimensionPlot"}\NormalTok{, }
    \DataTypeTok{slots=}\KeywordTok{c}\NormalTok{(}\DataTypeTok{BinResolution=}\StringTok{"numeric"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Any new slots should come with validity methods, as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(val <-}\StringTok{ }\NormalTok{object[[}\StringTok{"BinResolution"}\NormalTok{]])}\OperatorTok{!=}\NormalTok{1L }\OperatorTok{||}\StringTok{ }\NormalTok{val }\OperatorTok{<=}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'BinResolution' must be a positive number"}\NormalTok{)}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We specialize the \texttt{initialize()} method to provide a default for the new parameter.
We also define a constructor function to make it easier to create a new instance.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{,}
    \ControlFlowTok{function}\NormalTok{(.Object, }\DataTypeTok{BinResolution=}\DecValTok{100}\NormalTok{, ...)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{BinResolution=}\NormalTok{BinResolution, ...)}
\NormalTok{\})}

\NormalTok{RedDimHexPlot <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{new}\NormalTok{(}\StringTok{"RedDimHexPlot"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

At this point, we can already create and use instances of this new panel class in \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} apps.
However, that would not be very exciting as instances of this new panel class would behave exactly like the those of the parent \texttt{ReducedDimensionPlot} class.
Let's define a few more methods to introduce some more relevant differences in behavior.

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

Currently, instances of our new class are indistinguishable from the parent \texttt{ReducedDimensionPlot} in the \texttt{iSEE} interface.
To differentiate our new class, we create a method for the \texttt{.fullName()} generic to show a different name.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Reduced dimension hexagonal plot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

While we're here, we might as well give the panel a different color as well.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#AA5500"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also override aspects of the user interface to add a parameter to modify the bin resolution.
Here, we place a \texttt{numericInput} widget into the set of parameters controlling the size aesthetics.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineVisualSizeInterface"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{tagList}\NormalTok{(}
        \KeywordTok{numericInput}\NormalTok{(}
            \KeywordTok{paste0}\NormalTok{(plot_name, }\StringTok{"_"}\NormalTok{, }\StringTok{"BinResolution"}\NormalTok{), }\DataTypeTok{label=}\StringTok{"Bin resolution:"}\NormalTok{,}
            \DataTypeTok{min=}\DecValTok{1}\NormalTok{, }\DataTypeTok{value=}\NormalTok{x[[}\StringTok{"BinResolution"}\NormalTok{]], }\DataTypeTok{step =} \DecValTok{1}\NormalTok{)}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Conversely, some other aspects of the UI are now irrelevant because we are no longer showing individual points.
This includes the shape of the points, point-related downsampling and a variety of other aesthetic features.
Thus, we hide or disable them to avoid cluttering the interface.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".hideInterface"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, field) \{}
    \ControlFlowTok{if}\NormalTok{ (field }\OperatorTok{==}\StringTok{ "Downsample"}\NormalTok{) }\OtherTok{TRUE} \ControlFlowTok{else} \KeywordTok{callNextMethod}\NormalTok{()}
\NormalTok{\})}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineVisualShapeInterface"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
    \OtherTok{NULL}
\NormalTok{\})}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineVisualOtherInterface"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
    \OtherTok{NULL}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

The only new UI element we added was the widget to control the bin resolution.
Thus, the only new observer that needs to be added is the one that respects to this element.
Note the use of \texttt{callNextMethod()} to ensure that the observers for the parent class are also instantiated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects) \{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createProtectedParameterObservers}\NormalTok{(plot_name,}
        \DataTypeTok{fields=}\KeywordTok{c}\NormalTok{(}\StringTok{"BinResolution"}\NormalTok{),}
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}

    \KeywordTok{invisible}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{generating-the-plot}{%
\section{Generating the plot}\label{generating-the-plot}}

We create a method for the \texttt{.generateDotPlot()} generic to implement our hexbinning strategy.
The contract for this generic guarantees that our method can immediately rely on the \texttt{plot.data} data-frame that is computed by methods defined for the parent \texttt{ReducedDimensionPlot} class.
We also use the precomputed aesthetic \texttt{labels} associated with each column of \texttt{plot.data}, while setting a fixed label \texttt{"Count"} for the \texttt{fill} aesthetic associated with the count of observation in each hexagonal bin.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".generateDotPlot"}\NormalTok{, }\StringTok{"RedDimHexPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, labels, envir) \{}
\NormalTok{    plot_cmds <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{    plot_cmds[[}\StringTok{"ggplot"}\NormalTok{]] <-}\StringTok{ "dot.plot <- ggplot() +"}
    
    \CommentTok{# Adding hexbins to the plot.}
\NormalTok{    plot_cmds[[}\StringTok{"hex"}\NormalTok{]] <-}\StringTok{ "geom_hex(aes(X, Y), plot.data) +"}
\NormalTok{    plot_cmds[[}\StringTok{"labs"}\NormalTok{]] <-}\StringTok{ "labs(fill='Count') +"}
\NormalTok{    plot_cmds[[}\StringTok{"labs"}\NormalTok{]] <-}\StringTok{ }\KeywordTok{sprintf}\NormalTok{(}
        \StringTok{"labs(x='%s', y='%s', title='%s', fill='%s') +"}\NormalTok{,}
\NormalTok{        labels}\OperatorTok{$}\NormalTok{X, labels}\OperatorTok{$}\NormalTok{Y, labels}\OperatorTok{$}\NormalTok{title, }\StringTok{"Count"}
\NormalTok{        )}
\NormalTok{    plot_cmds[[}\StringTok{"theme_base"}\NormalTok{]] <-}\StringTok{ "theme_bw() +"}
\NormalTok{    plot_cmds[[}\StringTok{"theme_legend"}\NormalTok{]] <-}\StringTok{ "theme(legend.position = 'bottom')"}

    \CommentTok{# Adding a faceting command, if applicable.}
\NormalTok{    facet_cmd <-}\StringTok{ }\KeywordTok{.addFacets}\NormalTok{(x)}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(facet_cmd)) \{}
\NormalTok{        N <-}\StringTok{ }\KeywordTok{length}\NormalTok{(plot_cmds)}
\NormalTok{        plot_cmds[[N]] <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(plot_cmds[[N]], }\StringTok{"+"}\NormalTok{)}
\NormalTok{        plot_cmds <-}\StringTok{ }\KeywordTok{c}\NormalTok{(plot_cmds, facet_cmd)}
\NormalTok{    \}}

    \CommentTok{# Adding self-brushing boxes, if they exist.}
\NormalTok{    plot_cmds <-}\StringTok{ }\KeywordTok{.addMultiSelectionPlotCommands}\NormalTok{(x,}
        \DataTypeTok{envir=}\NormalTok{envir, }\DataTypeTok{commands=}\NormalTok{plot_cmds)}

\NormalTok{    gg_plot <-}\StringTok{ }\KeywordTok{.textEval}\NormalTok{(plot_cmds, envir)}

    \KeywordTok{list}\NormalTok{(}\DataTypeTok{plot=}\NormalTok{gg_plot, }\DataTypeTok{commands=}\NormalTok{plot_cmds)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

For brevity, we have omitted the more tiresome parts of coloring the bins with respect to assay values or metadata variables.
However, it is relatively straightforward to extend \texttt{.generateDotPlot()} to ensure that it responds to such choices as well as any other relevant parameters in \texttt{x} (e.g., font size).

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

To demonstrate, we will load a small example dataset \citep{tasic2016adult} from the \emph{\href{https://bioconductor.org/packages/3.11/scRNAseq}{scRNAseq}} package.
This is provided as a \texttt{SingleCellExperiment} on which we compute the usual \(t\)-SNE plot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(scRNAseq)}
\NormalTok{sce <-}\StringTok{ }\KeywordTok{ReprocessedAllenData}\NormalTok{(}\DataTypeTok{assays=}\StringTok{"tophat_counts"}\NormalTok{)}

\KeywordTok{set.seed}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{library}\NormalTok{(scater)}
\NormalTok{sce <-}\StringTok{ }\KeywordTok{logNormCounts}\NormalTok{(sce, }\DataTypeTok{exprs_values=}\StringTok{"tophat_counts"}\NormalTok{)}
\NormalTok{sce <-}\StringTok{ }\KeywordTok{runPCA}\NormalTok{(sce, }\DataTypeTok{ncomponents=}\DecValTok{4}\NormalTok{)}
\NormalTok{sce <-}\StringTok{ }\KeywordTok{runTSNE}\NormalTok{(sce)}
\end{Highlighting}
\end{Shaded}

We now set up an \texttt{iSEE()} instance with the hexbin and standard plots for showing reduced dimension results.
We can see the obvious visual differences in the aesthetics between plots as well as the changes to the user interface.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(}
    \KeywordTok{ReducedDimensionPlot}\NormalTok{(}\DataTypeTok{Type=}\StringTok{"TSNE"}\NormalTok{, }\DataTypeTok{VisualBoxOpen=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{VisualChoices=}\StringTok{"Size"}\NormalTok{),}
    \KeywordTok{RedDimHexPlot}\NormalTok{(}\DataTypeTok{Type=}\StringTok{"TSNE"}\NormalTok{, }\DataTypeTok{VisualBoxOpen=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{VisualChoices=}\StringTok{"Size"}\NormalTok{)}
\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/hex-dimred}

\hypertarget{dynamic-reduced-dimensions}{%
\chapter{Dynamic reduced dimensions}\label{dynamic-reduced-dimensions}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

In this case study, we will create a custom panel class to regenerate sample-level PCA coordinates using only a subset of points transmitted as a multiple column selection from another panel.
We call this a \textbf{dynamic reduced dimension plot}, as it is dynamically recomputing the dimensionality reduction results rather than using pre-computed values in the \texttt{reducedDims()} slot of a \texttt{SingleCellExperiment} object.
This proposed class is the basis of the \texttt{DynamicReducedDimensionPlot} from the \emph{\href{https://bioconductor.org/packages/3.11/iSEEu}{iSEEu}} package.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

First, we define the basics of our new \texttt{Panel} class.
As our new class will be showing each sample as a point, we inherit from the \texttt{ColumnDotPlot} virtual class.
This automatically gives us access to all the functionality promised in the contract,
including interface elements and observers to handle multiple selections and respond to aesthetic parameters.

We add a slot specifying the type of dimensionality reduction result and the number of highly variable genes to use.
Any new slots should also come with validity methods, as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(n <-}\StringTok{ }\NormalTok{object[[}\StringTok{"NGenes"}\NormalTok{]])}\OperatorTok{!=}\NormalTok{1L }\OperatorTok{||}\StringTok{ }\NormalTok{n }\OperatorTok{<}\StringTok{ }\NormalTok{1L) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'NGenes' must be a positive integer scalar"}\NormalTok{) }
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{isSingleString}\NormalTok{(val <-}\StringTok{ }\NormalTok{object[[}\StringTok{"Type"}\NormalTok{]]) }\OperatorTok{||}\StringTok{ }
\StringTok{        }\OperatorTok{!}\NormalTok{val }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"PCA"}\NormalTok{, }\StringTok{"TSNE"}\NormalTok{, }\StringTok{"UMAP"}\NormalTok{)) }
\NormalTok{    \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'Type' must be one of 'TSNE', 'PCA' or 'UMAP'"}\NormalTok{)}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We specialize the \texttt{initialize()} method to provide a default for new parameters.
We also implement a constructor for instances of this class.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }
    \ControlFlowTok{function}\NormalTok{(.Object, }\DataTypeTok{Type=}\StringTok{"PCA"}\NormalTok{, }\DataTypeTok{NGenes=}\NormalTok{1000L, ...) }
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{Type=}\NormalTok{Type, }\DataTypeTok{NGenes=}\NormalTok{NGenes, ...)}
\NormalTok{\})}

\NormalTok{DynRedDimPlot <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{new}\NormalTok{(}\StringTok{"DynRedDimPlot"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

The most basic requirement is to define some methods that describe our new panel in the \texttt{iSEE()} interface.
This includes defining the full name and desired default color for display purposes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Dynamic reduced dimension plot"}\NormalTok{)}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#0F0F0F"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also add interface elements to change the result type and the number of genes.
This is most easily done by specializing the \texttt{.defineDataInterface} method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineDataInterface"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, select_info) \{}
\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{list}\NormalTok{(}
        \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(plot_name, }\StringTok{"_Type"}\NormalTok{), }\DataTypeTok{label=}\StringTok{"Type:"}\NormalTok{,}
            \DataTypeTok{choices=}\KeywordTok{c}\NormalTok{(}\StringTok{"PCA"}\NormalTok{, }\StringTok{"TSNE"}\NormalTok{, }\StringTok{"UMAP"}\NormalTok{), }\DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"Type"}\NormalTok{]]),}
        \KeywordTok{numericInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(plot_name, }\StringTok{"_NGenes"}\NormalTok{), }\DataTypeTok{label=}\StringTok{"Number of HVGs:"}\NormalTok{,}
            \DataTypeTok{min=}\DecValTok{1}\NormalTok{, }\DataTypeTok{value=}\NormalTok{x[[}\StringTok{"NGenes"}\NormalTok{]])}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We call \texttt{.getEncodedName()} to obtain a unique name for the current instance of our panel, e.g., \texttt{DynRedDimPlot1}.
We then \texttt{paste0} the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel;
otherwise, multiple \texttt{DynRedDimPlot}s would override each other.
One can imagine this as a poor man's Shiny module.

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

We specialize \texttt{.createObservers} to define some observers to respond to changes in our new interface elements.
Note the use of \texttt{callNextMethod()} to ensure that observers of the parent class are also created;
this automatically ensures that we can respond to changes in parameters provided by \texttt{ColumnDotPlot}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }
    \ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects) }
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createProtectedParameterObservers}\NormalTok{(plot_name,}
        \DataTypeTok{fields=}\KeywordTok{c}\NormalTok{(}\StringTok{"Type"}\NormalTok{, }\StringTok{"NGenes"}\NormalTok{),}
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Both the \texttt{NGenes} and \texttt{Type} parameters are what we consider to be ``protected'' parameters,
as changing them will alter the nature of the displayed plot.
We use the \texttt{.createProtectedParameterObservers()} utility to set up observers for both parameters,
which will instruct \texttt{iSEE()} to destroy existing brushes and lassos when these parameters are changed.
The idea here is that brushes/lassos made on the previous plot do not make sense when the coordinates are recomputed.

For this particular panel class, an additional helpful feature is to override \texttt{.multiSelectionInvalidated}.
This indicates that any brushes or lassos in our plot should be destroyed when we receive a new column selection.
Doing so is the only sensible course of action as the reduced dimension coordinates for one set of samples have no obvious relationship to the coordinates for another set of samples;
having old brushes or lassos hanging around would be of no benefit at best, and be misleading at worst.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionInvalidated"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{making-the-plot}{%
\section{Making the plot}\label{making-the-plot}}

When working with a \texttt{ColumnDotPlot} subclass, the easiest way to change plotting content to override the \texttt{.generateDotPlotData} method.
This should add a \texttt{plot.data} variable to the \texttt{envir} environment that has columns \texttt{X} and \texttt{Y} and contains one row per column of the original \texttt{SummarizedExperiment}.
It should also return a character vector of R commands describing how that \texttt{plot.data} object was constructed.
The easiest way to do this is to create a character vector of commands and call \texttt{eval(parse(text=...),\ envir=envir)} to evaluate them within \texttt{envir}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".generateDotPlotData"}\NormalTok{, }\StringTok{"DynRedDimPlot"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, envir) \{}
\NormalTok{    commands <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{exists}\NormalTok{(}\StringTok{"col_selected"}\NormalTok{, }\DataTypeTok{envir=}\NormalTok{envir, }\DataTypeTok{inherits=}\OtherTok{FALSE}\NormalTok{)) \{}
\NormalTok{        commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(commands, }
            \StringTok{"plot.data <- data.frame(X=numeric(0), Y=numeric(0));"}\NormalTok{)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(commands,}
            \StringTok{".chosen <- unique(unlist(col_selected));"}\NormalTok{,}
            \StringTok{"set.seed(100000)"}\NormalTok{, }\CommentTok{# to avoid problems with randomization.}
            \KeywordTok{sprintf}\NormalTok{(}\StringTok{".coords <- scater::calculate%s(se[,.chosen], ntop=%i, ncomponents=2);"}\NormalTok{,}
\NormalTok{                x[[}\StringTok{"Type"}\NormalTok{]], x[[}\StringTok{"NGenes"}\NormalTok{]]),}
            \StringTok{"plot.data <- data.frame(.coords, row.names=.chosen);"}\NormalTok{,}
            \StringTok{"colnames(plot.data) <- c('X', 'Y');"}
\NormalTok{        )}
\NormalTok{    \}}

\NormalTok{    commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(commands,}
        \StringTok{"plot.data <- plot.data[colnames(se),,drop=FALSE];"}\NormalTok{,}
        \StringTok{"rownames(plot.data) <- colnames(se);"}\NormalTok{)}

    \KeywordTok{eval}\NormalTok{(}\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text=}\NormalTok{commands), }\DataTypeTok{envir=}\NormalTok{envir)}

    \KeywordTok{list}\NormalTok{(}\DataTypeTok{data_cmds=}\NormalTok{commands, }\DataTypeTok{plot_title=}\KeywordTok{sprintf}\NormalTok{(}\StringTok{"Dynamic %s plot"}\NormalTok{, x[[}\StringTok{"Type"}\NormalTok{]]), }
        \DataTypeTok{x_lab=}\KeywordTok{paste0}\NormalTok{(x[[}\StringTok{"Type"}\NormalTok{]], }\StringTok{"1"}\NormalTok{), }\DataTypeTok{y_lab=}\KeywordTok{paste0}\NormalTok{(x[[}\StringTok{"Type"}\NormalTok{]], }\StringTok{"2"}\NormalTok{))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We use functions from the \emph{\href{https://bioconductor.org/packages/3.11/scater}{scater}} package to do the actual heavy lifting of calculating the dimensionality reduction results.
The \texttt{exists()} call will check whether any column selection is being transmitted to this panel; if not, it will just return a \texttt{plot.data} variable that contains all \texttt{NA}s such that an empty plot is created.
If \texttt{col\_selected} does exist, it will contain a list of character vectors specifying the active and saved multiple selections that are being transmitted.
For this particular example, we do not care about the distinction between active/saved selections so we just take the union of all of them.

Of course, this is not quite the most efficient way to implement a plotting panel that involves recomputation.
A better approach would be to cache the x/y coordinates and reuse them if only aesthetic parameters have changed,
thus avoiding an unnecessary delay from recomputation.
Doing so requires overriding \texttt{.renderOutput()} to take advantage of the cached contents of the plot,
so we will omit that here for simplicity.

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

Let's put our new panel to the test.
We'll use the \texttt{sce} object from Chapter \ref{developing}, which includes some precomputed dimensionality reduction results.
The plan is to create a (fixed) reduced dimension plot that will transmit a multiple selection to our dynamic reduced dimension plot.
Brushing at any location in the former will then trigger dynamic recompution of results in the latter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rdp <-}\StringTok{ }\KeywordTok{ReducedDimensionPlot}\NormalTok{(}\DataTypeTok{PanelId=}\NormalTok{1L,}
    \DataTypeTok{BrushData =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{xmin =} \DecValTok{17}\NormalTok{, }\DataTypeTok{xmax =} \DecValTok{55}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{-36}\NormalTok{, }\DataTypeTok{ymax =} \DecValTok{29}\NormalTok{,}
        \DataTypeTok{coords_css =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{xmin =}\NormalTok{ 300L, }\DataTypeTok{xmax =}\NormalTok{ 450L, }\DataTypeTok{ymin =}\NormalTok{ 170L, }\DataTypeTok{ymax =}\NormalTok{ 404L),}
        \DataTypeTok{coords_img =} \KeywordTok{list}\NormalTok{( }\DataTypeTok{xmin =}\NormalTok{ 375L, }\DataTypeTok{xmax =} \DecValTok{562}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{212}\NormalTok{, }\DataTypeTok{ymax =}\NormalTok{ 505L),}
        \DataTypeTok{img_css_ratio =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\NormalTok{),}
        \DataTypeTok{mapping =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \StringTok{"X"}\NormalTok{, }\DataTypeTok{y =} \StringTok{"Y"}\NormalTok{),}
        \DataTypeTok{domain =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{-49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{57}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{-53}\NormalTok{, }\DataTypeTok{top =} \DecValTok{70}\NormalTok{),}
        \DataTypeTok{range =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{570}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{580}\NormalTok{, }\DataTypeTok{top =} \DecValTok{31}\NormalTok{),}
        \DataTypeTok{log =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{y =} \OtherTok{NULL}\NormalTok{),}
        \DataTypeTok{direction =} \StringTok{"xy"}\NormalTok{, }\DataTypeTok{brushId =} \StringTok{"ReducedDimensionPlot1_Brush"}\NormalTok{,}
        \DataTypeTok{outputId =} \StringTok{"ReducedDimensionPlot1"}
\NormalTok{    )}
\NormalTok{)}

\NormalTok{drdp <-}\StringTok{ }\KeywordTok{DynRedDimPlot}\NormalTok{(}\DataTypeTok{DataBoxOpen=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{ColumnSelectionSource=}\StringTok{"ReducedDimensionPlot1"}\NormalTok{)}
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(rdp, drdp))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/adaptive-dimred}

\hypertarget{dynamic-differential-expression}{%
\chapter{Dynamic differential expression}\label{dynamic-differential-expression}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

In this case study, we will create a panel class to dynamically compute differential expression (DE) statistics between the active sample-level selection and the other saved selections from a transmitting panel.
We will present the results of this computation in a \texttt{DataTable} widget from the \emph{\href{https://CRAN.R-project.org/package=DT}{DT}} package, where each row is a gene and each column is a relevant statistic (\(p\)-value, FDR, log-fold changes, etc.).
The class proposed here is the basis of the \texttt{DifferentialStatsticsTable} from \emph{\href{https://bioconductor.org/packages/3.11/iSEEu}{iSEEu}}.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

First, we define the basics of our new \texttt{Panel} class.
As our new class will be showing each gene as a row, we inherit from the \texttt{RowTable} virtual class.
This automatically gives us access to all the functionality promised in the contract,
including interface elements and observers to respond to multiple selections.
We also add a slot specifying the log-fold change threshold to use in the null hypothesis.

Any new slots should come with validity methods, as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(val <-}\StringTok{ }\NormalTok{object[[}\StringTok{"LogFC"}\NormalTok{]])}\OperatorTok{!=}\NormalTok{1L }\OperatorTok{||}\StringTok{ }\NormalTok{val }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'NGenes' must be a non-negative number"}\NormalTok{)}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

It is also worthwhile specializing the \texttt{initialize()} method to provide a default for new parameters.
We hard-code the \texttt{ColumnSelectionType} setting as we want to obtain all multiple selections from the transmitting panel,
in order to be able to perform pairwise DE analyses between the various active and saved selections.
(By comparison, the default of \texttt{"Active"} will only transmit the current active selection.)
We also define a constructor to conveniently create new instances.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }
    \ControlFlowTok{function}\NormalTok{(.Object, }\DataTypeTok{LogFC=}\DecValTok{0}\NormalTok{, ...) }
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{LogFC=}\NormalTok{LogFC, }\DataTypeTok{ColumnSelectionType=}\StringTok{"Union"}\NormalTok{, ...)}
\NormalTok{\})}

\NormalTok{DGETable <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{new}\NormalTok{(}\StringTok{"DGETable"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

The most basic requirement is to define some methods that describe our new panel in the \texttt{iSEE()} interface.
This includes defining the full name and desired default color for display purposes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Differential expression table"}\NormalTok{)}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#55AA00"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also add interface elements to change the result type and the number of genes.
This is most easily done by specializing the \texttt{.defineDataInterface()} generic.
We \texttt{paste0} the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(shiny)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineDataInterface"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, select_info) \{}
\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{list}\NormalTok{(}
        \KeywordTok{numericInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(plot_name, }\StringTok{"_LogFC"}\NormalTok{), }\DataTypeTok{label=}\StringTok{"Log-FC threshold"}\NormalTok{,}
            \DataTypeTok{min=}\DecValTok{0}\NormalTok{, }\DataTypeTok{value=}\NormalTok{x[[}\StringTok{"LogFC"}\NormalTok{]])}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

By default, all \texttt{RowTable}s hide their multiple column selection parameter choices.
This considers the typical use case where \texttt{RowTable}s respond to a selection of rows rather than a selection of columns.
For \texttt{DGETable}s, we need to flip this around by specializing \texttt{.hideInterface()} so that the unresponsive row selection parameters are hidden in the interface while the useful column selection parameters are visible.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".hideInterface"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, field) \{}
    \ControlFlowTok{if}\NormalTok{ (field }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"RowSelectionSource"}\NormalTok{, }\StringTok{"RowSelectionType"}\NormalTok{, }
        \StringTok{"RowSelectionSaved"}\NormalTok{, }\StringTok{"RowSelectionDynamicSource"}\NormalTok{)) \{}
        \OtherTok{TRUE}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (field }\OperatorTok{%in%}\StringTok{ "ColumnSelectionSource"}\NormalTok{) \{}
        \OtherTok{FALSE}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{callNextMethod}\NormalTok{()}
\NormalTok{    \}}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

A more advanced version of this panel class might consider responding to a row selection by only performing the DE analysis on the selected features.
In such cases, we would not need to hide \texttt{RowSelectionSource}, though we will leave that as an exercise for the curious.

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

We specialize \texttt{.createObservers} to define some observers to respond to changes in our new interface elements.
Note the use of \texttt{callNextMethod()} to ensure that observers of the parent class are also created;
this automatically ensures that we can respond to changes in parameters provided by \texttt{RowTable}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }
    \ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects) }
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createUnprotectedParameterObservers}\NormalTok{(plot_name,}
        \DataTypeTok{fields=}\StringTok{"LogFC"}\NormalTok{,}
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

The distinction between protected and unprotected parameters is less important for \texttt{Table}s;
as long as the types of the columns do not change between renderings, any column or global selections (i.e., search terms) are usually still sensible.

\hypertarget{making-the-table}{%
\section{Making the table}\label{making-the-table}}

When working with a \texttt{RowTable} subclass, the easiest way to change plotting content to override the \texttt{.generateTable} method.
This is expected to generate a \texttt{data.frame} in the evaluation environment, returning the commands required to do so.
In this case, we want to perform one-sided \(t\)-tests between the active selection and any number of saved selections.
We will use the \texttt{findMarkers()} function from \emph{\href{https://bioconductor.org/packages/3.11/scran}{scran}} to compute the desired statistics.
This performs all pairwise comparisons, so is not as efficient as could be, but it will suffice for this demonstration.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".generateTable"}\NormalTok{, }\StringTok{"DGETable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, envir) \{}
\NormalTok{    empty <-}\StringTok{ "tab <- data.frame(Top=integer(0), p.value=numeric(0), FDR=numeric(0));"}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{exists}\NormalTok{(}\StringTok{"col_selected"}\NormalTok{, envir, }\DataTypeTok{inherits=}\OtherTok{FALSE}\NormalTok{) }\OperatorTok{||}\StringTok{ }
\StringTok{        }\KeywordTok{length}\NormalTok{(envir}\OperatorTok{$}\NormalTok{col_selected)}\OperatorTok{<}\NormalTok{2L }\OperatorTok{||}\StringTok{ }
\StringTok{        }\OperatorTok{!}\StringTok{"active"} \OperatorTok{%in%}\StringTok{ }\KeywordTok{names}\NormalTok{(envir}\OperatorTok{$}\NormalTok{col_selected)) }
\NormalTok{    \{}
\NormalTok{        commands <-}\StringTok{ }\NormalTok{empty}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{".chosen <- unlist(col_selected);"}\NormalTok{,}
            \StringTok{".grouping <- rep(names(col_selected), lengths(col_selected));"}\NormalTok{,}
            \KeywordTok{sprintf}\NormalTok{(}\StringTok{".de.stats <- scran::findMarkers(logcounts(se)[,.chosen], }
\StringTok{    .grouping, direction='up', lfc=%s)"}\NormalTok{, x[[}\StringTok{"LogFC"}\NormalTok{]]),}
            \StringTok{"tab <- as.data.frame(.de.stats[['active']]);"}
\NormalTok{        )}
\NormalTok{    \}}
       
    \KeywordTok{eval}\NormalTok{(}\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text=}\NormalTok{commands), }\DataTypeTok{envir=}\NormalTok{envir)}

    \KeywordTok{list}\NormalTok{(}\DataTypeTok{commands=}\NormalTok{commands, }\DataTypeTok{contents=}\NormalTok{envir}\OperatorTok{$}\NormalTok{tab)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Readers may notice that we prefix internal variables with \texttt{.} in our commands.
This ensures that they do not clash with global variables created by \texttt{iSEE()} itself
(which is not an issue when running the app, but makes things difficult when the code is reported for tracking purposes).

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

Let's put our new panel to the test.
We'll use the \texttt{sce} object from Chapter \ref{developing}, which includes some precomputed dimensionality reduction results.
The plan is to create a (fixed) reduced dimension plot that will transmit to our DGE table.
We set up an iSEE instance with an existing brush on the former to trigger computation of differential results by the latter.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Setting up multiple active and saved brushes.}
\NormalTok{rdp <-}\StringTok{ }\KeywordTok{ReducedDimensionPlot}\NormalTok{(}\DataTypeTok{PanelId=}\NormalTok{1L,}
    \DataTypeTok{BrushData =} \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{xmin =} \DecValTok{17}\NormalTok{, }\DataTypeTok{xmax =} \DecValTok{55}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{-36}\NormalTok{, }\DataTypeTok{ymax =} \DecValTok{29}\NormalTok{, }
        \DataTypeTok{coords_css =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{xmin =}\NormalTok{ 300L, }\DataTypeTok{xmax =}\NormalTok{ 450L, }\DataTypeTok{ymin =}\NormalTok{ 170L, }\DataTypeTok{ymax =}\NormalTok{ 404L), }
        \DataTypeTok{coords_img =} \KeywordTok{list}\NormalTok{( }\DataTypeTok{xmin =}\NormalTok{ 375L, }\DataTypeTok{xmax =} \DecValTok{562}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{212}\NormalTok{, }\DataTypeTok{ymax =}\NormalTok{ 505L), }
        \DataTypeTok{img_css_ratio =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\NormalTok{), }
        \DataTypeTok{mapping =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \StringTok{"X"}\NormalTok{, }\DataTypeTok{y =} \StringTok{"Y"}\NormalTok{), }
        \DataTypeTok{domain =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{-49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{57}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{-53}\NormalTok{, }\DataTypeTok{top =} \DecValTok{70}\NormalTok{), }
        \DataTypeTok{range =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{570}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{580}\NormalTok{, }\DataTypeTok{top =} \DecValTok{31}\NormalTok{), }
        \DataTypeTok{log =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{y =} \OtherTok{NULL}\NormalTok{), }
        \DataTypeTok{direction =} \StringTok{"xy"}\NormalTok{, }\DataTypeTok{brushId =} \StringTok{"ReducedDimensionPlot1_Brush"}\NormalTok{, }
        \DataTypeTok{outputId =} \StringTok{"ReducedDimensionPlot1"}
\NormalTok{    ),}
    \DataTypeTok{SelectionHistory =} \KeywordTok{list}\NormalTok{(}
        \KeywordTok{list}\NormalTok{(}
            \DataTypeTok{xmin =} \DecValTok{-44}\NormalTok{, }\DataTypeTok{xmax =} \DecValTok{-1}\NormalTok{, }\DataTypeTok{ymin =} \DecValTok{5}\NormalTok{, }\DataTypeTok{ymax =} \DecValTok{59}\NormalTok{, }
            \DataTypeTok{coords_css =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{xmin =}\NormalTok{ 57L, }\DataTypeTok{xmax =}\NormalTok{ 225L, }\DataTypeTok{ymin =}\NormalTok{ 64L, }\DataTypeTok{ymax =}\NormalTok{ 254L), }
            \DataTypeTok{coords_img =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{xmin =} \DecValTok{71}\NormalTok{, }\DataTypeTok{xmax =} \DecValTok{281}\NormalTok{, }\DataTypeTok{ymin =}\NormalTok{ 80L, }\DataTypeTok{ymax =} \DecValTok{317}\NormalTok{), }
            \DataTypeTok{img_css_ratio =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\NormalTok{), }
            \DataTypeTok{mapping =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \StringTok{"X"}\NormalTok{, }\DataTypeTok{y =} \StringTok{"Y"}\NormalTok{), }
            \DataTypeTok{domain =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{-49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{57}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{-53}\NormalTok{, }\DataTypeTok{top =} \DecValTok{70}\NormalTok{), }
            \DataTypeTok{range =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{left =} \DecValTok{49}\NormalTok{, }\DataTypeTok{right =} \DecValTok{570}\NormalTok{, }\DataTypeTok{bottom =} \DecValTok{580}\NormalTok{, }\DataTypeTok{top =} \DecValTok{31}\NormalTok{), }
            \DataTypeTok{log =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{y =} \OtherTok{NULL}\NormalTok{), }
            \DataTypeTok{direction =} \StringTok{"xy"}\NormalTok{, }\DataTypeTok{brushId =} \StringTok{"ReducedDimensionPlot1_Brush"}\NormalTok{, }
            \DataTypeTok{outputId =} \StringTok{"ReducedDimensionPlot1"}
\NormalTok{        )}
\NormalTok{    )}
\NormalTok{) }

\NormalTok{dget <-}\StringTok{ }\KeywordTok{DGETable}\NormalTok{(}\DataTypeTok{ColumnSelectionSource=}\StringTok{"ReducedDimensionPlot1"}\NormalTok{, }
    \DataTypeTok{PanelWidth=}\NormalTok{8L, }\DataTypeTok{DataBoxOpen=}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(rdp, dget))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/de-table}

\hypertarget{annotated-gene-list}{%
\chapter{Annotated gene list}\label{annotated-gene-list}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

When given a gene list, we often need to look up the function of the top genes in a search engine.
This typically involves copy-pasting the gene name or ID into the search box and pressing Enter, which is a pain.
Instead, we can automate this process in \emph{\href{https://bioconductor.org/packages/3.11/iSEE}{iSEE}} by creating an \textbf{annotated gene table} that dynamically looks up annotation for each gene in the \texttt{rowData} of a \texttt{SummarizedExperiment}.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

First, we define the basics of our new \texttt{Panel} class.
Our new class will be showing the gene-level metadata, so we inherit from the \texttt{RowDataTable} class that does exactly this.
We add some slots specifying which column of the table contains our gene IDs, the type of ID and the organism database to use.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(iSEE)}
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"GeneAnnoTable"}\NormalTok{, }\DataTypeTok{contains=}\StringTok{"RowDataTable"}\NormalTok{,}
    \DataTypeTok{slots=}\KeywordTok{c}\NormalTok{(}
        \DataTypeTok{IDColumn=}\StringTok{"character_OR_NULL"}\NormalTok{, }
        \DataTypeTok{IDType=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{Organism=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{AnnoBoxOpen=}\StringTok{"logical"}
\NormalTok{    )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We specialize the validity method to check that the \texttt{IDColumn} is either a string or \texttt{NULL};
if the latter, we assume that the ID is stored in the row name.
We also add some cursory checks for the other parameters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{allowable <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"ENSEMBL"}\NormalTok{, }\StringTok{"SYMBOL"}\NormalTok{, }\StringTok{"ENTREZID"}\NormalTok{)}
\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(val <-}\StringTok{ }\NormalTok{object[[}\StringTok{"IDColumn"}\NormalTok{]]) }\OperatorTok{&&}\StringTok{ }\NormalTok{(}\KeywordTok{length}\NormalTok{(val)}\OperatorTok{!=}\NormalTok{1L }\OperatorTok{||}\StringTok{ }\KeywordTok{is.na}\NormalTok{(val))) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'IDColumn must be NULL or a string"}\NormalTok{)}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{isSingleString}\NormalTok{(orgdb <-}\StringTok{ }\NormalTok{object[[}\StringTok{"Organism"}\NormalTok{]])) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\KeywordTok{sprintf}\NormalTok{(}\StringTok{"'Organism' should be a single string"}\NormalTok{, orgdb))}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{isSingleString}\NormalTok{(type <-}\StringTok{ }\NormalTok{object[[}\StringTok{"IDType"}\NormalTok{]]) }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\NormalTok{type }\OperatorTok{%in%}\StringTok{ }\NormalTok{allowable) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'IDType' should be 'ENSEMBL', 'SYMBOL' or 'ENTREZID'"}\NormalTok{)}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(open <-}\StringTok{ }\NormalTok{object[[}\StringTok{"AnnoBoxOpen"}\NormalTok{]])}\OperatorTok{!=}\NormalTok{1L }\OperatorTok{||}\StringTok{ }\KeywordTok{is.na}\NormalTok{(open)) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'AnnoBoxOpen' should be a non-missing logical scalar"}\NormalTok{)}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We then specialize the initialize method to set reasonable defaults for these parameters.
We also provide a constructor to conveniently create new instances.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(.Object, }\DataTypeTok{IDColumn=}\OtherTok{NULL}\NormalTok{, }
    \DataTypeTok{Organism=}\StringTok{"org.Mm.eg.db"}\NormalTok{, }\DataTypeTok{IDType=}\StringTok{"SYMBOL"}\NormalTok{, }\DataTypeTok{AnnoBoxOpen=}\OtherTok{FALSE}\NormalTok{, ...)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{IDColumn=}\NormalTok{IDColumn, }\DataTypeTok{IDType=}\NormalTok{IDType,}
        \DataTypeTok{Organism=}\NormalTok{Organism, }\DataTypeTok{AnnoBoxOpen=}\NormalTok{AnnoBoxOpen, ...)}
\NormalTok{\})}

\NormalTok{GeneAnnoTable <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{new}\NormalTok{(}\StringTok{"GeneAnnoTable"}\NormalTok{, ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

We define the full name and desired default color for display purposes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Annotated gene table"}\NormalTok{)}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#AA1122"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We want to add another UI element for showing the gene-level annotation.
This is achieved by specializing the \texttt{.defineOutput()} method as shown below;
note the prefixing by the panel name to ensure that output element IDs from different panels are unique.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineOutput"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{tagList}\NormalTok{(}
        \KeywordTok{callNextMethod}\NormalTok{(), }\CommentTok{# Re-using RowDataTable's definition.}
        \KeywordTok{uiOutput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_annotation"}\NormalTok{)),}
        \KeywordTok{hr}\NormalTok{()}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We also set up interface elements for changing the annotation parameters.
We will put these elements in a separate ``Annotation parameters'' collapsible box,
which is initialized in an opened or closed state depending on the \texttt{AnnoBoxOpen} slot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineInterface"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, select_info) \{}
\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{c}\NormalTok{(}
        \KeywordTok{list}\NormalTok{(}
            \KeywordTok{collapseBox}\NormalTok{(}
                \KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_AnnoBoxOpen"}\NormalTok{),}
                \DataTypeTok{title=}\StringTok{"Annotation parameters"}\NormalTok{,}
                \DataTypeTok{open=}\NormalTok{x[[}\StringTok{"AnnoBoxOpen"}\NormalTok{]],}
                \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_IDColumn"}\NormalTok{),}
                    \DataTypeTok{label=}\StringTok{"ID-containing column:"}\NormalTok{,}
                    \DataTypeTok{choices=}\KeywordTok{colnames}\NormalTok{(}\KeywordTok{rowData}\NormalTok{(se)), }
                    \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"IDColumn"}\NormalTok{]]}
\NormalTok{                ),}
                \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_IDType"}\NormalTok{),}
                    \DataTypeTok{label=}\StringTok{"ID type:"}\NormalTok{,}
                    \DataTypeTok{choices=}\NormalTok{allowable,}
                    \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"IDType"}\NormalTok{]]}
\NormalTok{                ),}
                \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_Organism"}\NormalTok{),}
                    \DataTypeTok{label=}\StringTok{"Organism"}\NormalTok{,}
                    \DataTypeTok{choices=}\KeywordTok{c}\NormalTok{(}\StringTok{"org.Hs.eg.db"}\NormalTok{, }\StringTok{"org.Mm.eg.db"}\NormalTok{),}
                    \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"Organism"}\NormalTok{]]}
\NormalTok{                )}
\NormalTok{            )}
\NormalTok{        ),}
        \KeywordTok{callNextMethod}\NormalTok{()}
\NormalTok{    ) }
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

We specialize \texttt{.createObservers} to define some observers to respond to changes in our new interface elements.
Note the use of \texttt{callNextMethod()} to ensure that observers of the parent class are also created.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{,}
    \ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    plot_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createUnprotectedParameterObservers}\NormalTok{(plot_name,}
        \DataTypeTok{fields=}\KeywordTok{c}\NormalTok{(}\StringTok{"IDColumn"}\NormalTok{, }\StringTok{"Organism"}\NormalTok{, }\StringTok{"IDType"}\NormalTok{), }
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We need to set up a rendering expression for the annotation element that responds to the selected gene.
By using \texttt{.trackSingleSelection()}, we ensure that this UI element updates in response to changes in the table selection.
We add a series of protective measures to avoid the application crashing due to missing organism packages or unmatched IDs.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".renderOutput"}\NormalTok{, }\StringTok{"GeneAnnoTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, ..., output, pObjects, rObjects) \{}
    \KeywordTok{callNextMethod}\NormalTok{() }\CommentTok{# Re-using RowDataTable's output rendering.}

\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
\NormalTok{    output[[}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_annotation"}\NormalTok{)]] <-}\StringTok{ }\KeywordTok{renderUI}\NormalTok{(\{}
        \KeywordTok{.trackSingleSelection}\NormalTok{(panel_name, rObjects)}
\NormalTok{        instance <-}\StringTok{ }\NormalTok{pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]]}

\NormalTok{        rowdata_col <-}\StringTok{ }\NormalTok{instance[[}\StringTok{"IDColumn"}\NormalTok{]]}
\NormalTok{        selectedGene <-}\StringTok{ }\NormalTok{instance[[}\StringTok{"Selected"}\NormalTok{]]}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(rowdata_col)) \{}
\NormalTok{            selectedGene <-}\StringTok{ }\KeywordTok{rowData}\NormalTok{(se)[selectedGene,rowdata_col]}
\NormalTok{        \}}

\NormalTok{        keytype <-}\StringTok{ }\NormalTok{instance[[}\StringTok{"IDType"}\NormalTok{]]}
\NormalTok{        selgene_entrez <-}\StringTok{ }\OtherTok{NA}
        \ControlFlowTok{if}\NormalTok{ (keytype}\OperatorTok{!=}\StringTok{"ENTREZID"}\NormalTok{) \{}
\NormalTok{            ORG <-}\StringTok{ }\NormalTok{instance[[}\StringTok{"Organism"}\NormalTok{]]}
            \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{require}\NormalTok{(ORG, }\DataTypeTok{character.only=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{quietly=}\OtherTok{TRUE}\NormalTok{)) \{}
\NormalTok{                orgdb <-}\StringTok{ }\KeywordTok{get}\NormalTok{(ORG)}
\NormalTok{                selgene_entrez <-}\StringTok{ }\KeywordTok{try}\NormalTok{(}\KeywordTok{mapIds}\NormalTok{(orgdb, selectedGene, }\StringTok{"ENTREZID"}\NormalTok{, keytype), }
                    \DataTypeTok{silent=}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{            \}}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            selgene_entrez <-}\StringTok{ }\NormalTok{selectedGene}
\NormalTok{        \}}

        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.na}\NormalTok{(selgene_entrez) }\OperatorTok{||}\StringTok{ }\KeywordTok{is}\NormalTok{(selgene_entrez, }\StringTok{"try-error"}\NormalTok{)) \{}
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{        \}}

\NormalTok{        fullinfo <-}\StringTok{ }\NormalTok{rentrez}\OperatorTok{::}\KeywordTok{entrez_summary}\NormalTok{(}\StringTok{"gene"}\NormalTok{, selgene_entrez)}
\NormalTok{        link_pubmed <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{'<a href="http://www.ncbi.nlm.nih.gov/gene/?term='}\NormalTok{,}
\NormalTok{            selgene_entrez,}
            \StringTok{'" target="_blank">Click here to see more at the NCBI database</a>'}\NormalTok{)}

\NormalTok{        mycontent <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"<b>"}\NormalTok{,fullinfo}\OperatorTok{$}\NormalTok{name, }\StringTok{"</b><br/><br/>"}\NormalTok{,}
\NormalTok{            fullinfo}\OperatorTok{$}\NormalTok{description,}\StringTok{"<br/><br/>"}\NormalTok{,}
            \KeywordTok{ifelse}\NormalTok{(fullinfo}\OperatorTok{$}\NormalTok{summary }\OperatorTok{==}\StringTok{ ""}\NormalTok{,}\StringTok{""}\NormalTok{,}\KeywordTok{paste0}\NormalTok{(fullinfo}\OperatorTok{$}\NormalTok{summary, }\StringTok{"<br/><br/>"}\NormalTok{)),}
\NormalTok{            link_pubmed)}

        \KeywordTok{HTML}\NormalTok{(mycontent)}
\NormalTok{    \})}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Observant readers will note that the body of the rendering expression uses \texttt{pObjects\$memory{[}{[}panel\_name{]}{]}} rather than \texttt{x}.
This is intentional as it ensures that we are using the parameter settings from the current state of the app.
If we used \texttt{x}, we would always be using the parameters from the initial state of the app, which is not what we want.

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

Let's put our new panel to the test using the \texttt{sce} object from Chapter \ref{developing}.
We set up our \texttt{iSEE} instance such that clicking on any row will bring up the Entrez annotation (if available) for that feature.
It is probably best to click on some well-annotated genes as the set of RIKEN transcripts at the front don't have much annotation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gat <-}\StringTok{ }\KeywordTok{GeneAnnoTable}\NormalTok{(}\DataTypeTok{PanelWidth=}\NormalTok{8L, }\DataTypeTok{Selected=}\StringTok{"Snap25"}\NormalTok{, }\DataTypeTok{Search=}\StringTok{"Snap"}\NormalTok{)}
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(gat))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/anno-table}

\hypertarget{gene-ontology-table}{%
\chapter{Gene ontology table}\label{gene-ontology-table}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

Here, we will construct a table of GO terms where selection of a row in the table
causes transmission of a multiple selection of gene names.
The aim is to enable us to transmit multiple row selections to other panels based on their membership of a gene set.
This is a fairly involved example of creating a \texttt{Panel} subclass as we cannot easily inherit from an existing subclass; rather, we need to provide all the methods ourselves.
Readers may also be interested in the fully fledged version of the proposed class in \emph{\href{https://bioconductor.org/packages/3.11/iSEEu}{iSEEu}}.

\hypertarget{class-basics}{%
\section{Class basics}\label{class-basics}}

First, we define the basics of our new \texttt{GOTable} class.
This inherits from the virtual base \texttt{Panel} class as it cannot meet any of the contractual requirements of the subclasses,
what with the \texttt{DataTable} selection event triggering a multiple selection rather than a single selection.
We add some slots to specify the feature ID type and the organism of interest as well as for \texttt{DataTable} parameters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(iSEE)}
\KeywordTok{library}\NormalTok{(S4Vectors)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"GOTable"}\NormalTok{, }\DataTypeTok{contains=}\StringTok{"Panel"}\NormalTok{,}
    \DataTypeTok{slots=}\KeywordTok{c}\NormalTok{(}
        \DataTypeTok{IDType=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{Organism=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{Selected=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{Search=}\StringTok{"character"}\NormalTok{,}
        \DataTypeTok{SearchColumns=}\StringTok{"character"}
\NormalTok{    )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We also add some checks for these parameters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{allowable <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"ENSEMBL"}\NormalTok{, }\StringTok{"SYMBOL"}\NormalTok{, }\StringTok{"ENTREZID"}\NormalTok{)}
\KeywordTok{setValidity2}\NormalTok{(}\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{isSingleString}\NormalTok{(orgdb <-}\StringTok{ }\NormalTok{object[[}\StringTok{"Organism"}\NormalTok{]])) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\KeywordTok{sprintf}\NormalTok{(}\StringTok{"'Organism' should be a single string"}\NormalTok{, orgdb))}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{isSingleString}\NormalTok{(type <-}\StringTok{ }\NormalTok{object[[}\StringTok{"IDType"}\NormalTok{]]) }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\NormalTok{type }\OperatorTok{%in%}\StringTok{ }\NormalTok{allowable) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'IDType' should be 'ENSEMBL', 'SYMBOL' or 'ENTREZID'"}\NormalTok{)}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{isSingleString}\NormalTok{(object[[}\StringTok{"Selected"}\NormalTok{]])) \{ }
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'Selected' should be a single string"}\NormalTok{)}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{isSingleString}\NormalTok{(object[[}\StringTok{"Search"}\NormalTok{]])) \{}
\NormalTok{        msg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(msg, }\StringTok{"'Search' should be a single string"}\NormalTok{)}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(msg)) \{}
        \KeywordTok{return}\NormalTok{(msg)}
\NormalTok{    \}}
    \OtherTok{TRUE}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We then specialize the initialize method to set reasonable defaults and create an approprpiate constructor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"initialize"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(.Object, }
    \DataTypeTok{Organism=}\StringTok{"org.Mm.eg.db"}\NormalTok{, }\DataTypeTok{IDType=}\StringTok{"SYMBOL"}\NormalTok{, }
    \DataTypeTok{Selected=}\StringTok{""}\NormalTok{, }\DataTypeTok{Search=}\StringTok{""}\NormalTok{, }\DataTypeTok{SearchColumns=}\KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{), ...)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{(.Object, }\DataTypeTok{IDType=}\NormalTok{IDType, }\DataTypeTok{Organism=}\NormalTok{Organism, }
        \DataTypeTok{Selected=}\NormalTok{Selected, }\DataTypeTok{Search=}\NormalTok{Search, }
        \DataTypeTok{SearchColumns=}\NormalTok{SearchColumns, ...)}
\NormalTok{\})}

\NormalTok{GOTable <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{new}\NormalTok{(}\StringTok{"GOTable"}\NormalTok{, ...)}
\end{Highlighting}
\end{Shaded}

\hypertarget{setting-up-the-interface}{%
\section{Setting up the interface}\label{setting-up-the-interface}}

We define the full name and desired default color for display purposes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".fullName"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Gene ontology table"}\NormalTok{)}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".panelColor"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"#BB00FF"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We add our UI element for showing the gene set table, which is simply a \texttt{DataTable} object from the \emph{\href{https://CRAN.R-project.org/package=DT}{DT}} package.
Note that \emph{\href{https://CRAN.R-project.org/package=shiny}{shiny}} also has a \texttt{dataTableOutput} function so care must be taken to disambiguate them.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineOutput"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{tagList}\NormalTok{(DT}\OperatorTok{::}\KeywordTok{dataTableOutput}\NormalTok{(panel_name))}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We set up interface elements for changing the annotation parameters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".defineDataInterface"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, select_info) \{}
\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
    \KeywordTok{list}\NormalTok{(}
        \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_IDType"}\NormalTok{),}
            \DataTypeTok{label=}\StringTok{"ID type:"}\NormalTok{,}
            \DataTypeTok{choices=}\NormalTok{allowable,}
            \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"IDType"}\NormalTok{]]}
\NormalTok{        ),}
        \KeywordTok{selectInput}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_Organism"}\NormalTok{),}
            \DataTypeTok{label=}\StringTok{"Organism"}\NormalTok{,}
            \DataTypeTok{choices=}\KeywordTok{c}\NormalTok{(}\StringTok{"org.Hs.eg.db"}\NormalTok{, }\StringTok{"org.Mm.eg.db"}\NormalTok{),}
            \DataTypeTok{selected=}\NormalTok{x[[}\StringTok{"Organism"}\NormalTok{]]}
\NormalTok{        )}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Our implementation will be a pure transmitter, i.e., it will not respond to row or column selections from other panels.
To avoid confusion, we can hide all selection parameter UI elements by specializing the \texttt{.hideInterface()} method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".hideInterface"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, field) \{}
    \ControlFlowTok{if}\NormalTok{ (field }\OperatorTok{%in%}\StringTok{ "SelectionBoxOpen"}\NormalTok{) \{}
        \OtherTok{TRUE}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{callNextMethod}\NormalTok{()}
\NormalTok{    \}}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{generating-the-output}{%
\section{Generating the output}\label{generating-the-output}}

We actually generate the output by specializing the \texttt{.generateOutput()} function,
using the \emph{\href{https://bioconductor.org/packages/3.11/GO.db}{GO.db}} package to create a table of GO terms and their definitions.
We also store the number of available genes in the \texttt{contents} -
this will be used later to compute the percentage of all genes in a given gene set.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".generateOutput"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, ..., all_memory, all_contents) \{}
\NormalTok{    envir <-}\StringTok{ }\KeywordTok{new.env}\NormalTok{()}
\NormalTok{    commands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"require(GO.db);"}\NormalTok{,}
        \StringTok{"tab <- select(GO.db, keys=keys(GO.db), columns='TERM');"}\NormalTok{,}
        \StringTok{"rownames(tab) <- tab$GOID;"}\NormalTok{,}
        \StringTok{"tab$GOID <- NULL;"}\NormalTok{)}
    \KeywordTok{eval}\NormalTok{(}\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text=}\NormalTok{commands), }\DataTypeTok{envir=}\NormalTok{envir)}
    \KeywordTok{list}\NormalTok{(}
        \DataTypeTok{commands=}\KeywordTok{list}\NormalTok{(commands), }
        \DataTypeTok{contents=}\KeywordTok{list}\NormalTok{(}\DataTypeTok{table=}\NormalTok{envir}\OperatorTok{$}\NormalTok{tab, }\DataTypeTok{available=}\KeywordTok{nrow}\NormalTok{(se)),}
        \DataTypeTok{varname=}\StringTok{"tab"}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We don't actually depend on any parameters of \texttt{x} itself to generate this table.
However, one could imagine a more complex case where the \texttt{GOTable} itself responds to a multiple row selection,
e.g., by subsetting to the gene sets that contain genes in the selected row.

\hypertarget{creating-the-observers}{%
\section{Creating the observers}\label{creating-the-observers}}

We specialize \texttt{.createObservers} to define some observers to respond to changes in our new interface elements.
This also involves creating an observer to respond to a change in the selection of a \texttt{DataTable} row,
calling \texttt{.requestActiveSelectionUpdate()} to trigger changes in panels that are receiving the multiple row selection.
(We set up observers for the search fields as well, as a courtesy to restore them properly upon re-rendering.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".createObservers"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{,}
    \ControlFlowTok{function}\NormalTok{(x, se, input, session, pObjects, rObjects)}
\NormalTok{\{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}

    \KeywordTok{.createUnprotectedParameterObservers}\NormalTok{(panel_name,}
        \DataTypeTok{fields=}\KeywordTok{c}\NormalTok{(}\StringTok{"Organism"}\NormalTok{, }\StringTok{"IDType"}\NormalTok{), }
        \DataTypeTok{input=}\NormalTok{input, }\DataTypeTok{pObjects=}\NormalTok{pObjects, }\DataTypeTok{rObjects=}\NormalTok{rObjects)}

    \CommentTok{# Observer for the DataTable row selection:}
\NormalTok{    select_field <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_rows_selected"}\NormalTok{)}
\NormalTok{    multi_name <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_"}\NormalTok{, iSEE}\OperatorTok{:::}\NormalTok{.flagMultiSelect)}
    \KeywordTok{observeEvent}\NormalTok{(input[[select_field]], \{}
\NormalTok{        chosen <-}\StringTok{ }\NormalTok{input[[select_field]]}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(chosen)}\OperatorTok{==}\NormalTok{0L) \{}
\NormalTok{            chosen <-}\StringTok{ ""} 
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            chosen <-}\StringTok{ }\KeywordTok{rownames}\NormalTok{(pObjects}\OperatorTok{$}\NormalTok{contents[[panel_name]]}\OperatorTok{$}\NormalTok{table)[chosen]}
\NormalTok{        \}}

\NormalTok{        previous <-}\StringTok{ }\NormalTok{pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"Selected"}\NormalTok{]]}
        \ControlFlowTok{if}\NormalTok{ (chosen}\OperatorTok{==}\NormalTok{previous) \{}
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{        \}}
\NormalTok{        pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"Selected"}\NormalTok{]] <-}\StringTok{ }\NormalTok{chosen}
        \KeywordTok{.requestActiveSelectionUpdate}\NormalTok{(panel_name, session, pObjects, rObjects, }\DataTypeTok{update_output=}\OtherTok{FALSE}\NormalTok{)}
\NormalTok{    \}, }\DataTypeTok{ignoreInit=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{ignoreNULL=}\OtherTok{FALSE}\NormalTok{)}

    \CommentTok{# Observer for the search field:}
\NormalTok{    search_field <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_search"}\NormalTok{)}
    \KeywordTok{observeEvent}\NormalTok{(input[[search_field]], \{}
\NormalTok{        search <-}\StringTok{ }\NormalTok{input[[search_field]]}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(search, pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"Search"}\NormalTok{]])) \{}
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{        \}}
\NormalTok{        pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"Search"}\NormalTok{]] <-}\StringTok{ }\NormalTok{search}
\NormalTok{    \})}

    \CommentTok{# Observer for the column search fields:}
\NormalTok{    colsearch_field <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(panel_name, }\StringTok{"_search_columns"}\NormalTok{)}
    \KeywordTok{observeEvent}\NormalTok{(input[[colsearch_field]], \{}
\NormalTok{        search <-}\StringTok{ }\NormalTok{input[[colsearch_field]]}
        \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(search, pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"SearchColumns"}\NormalTok{]])) \{}
            \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{        \}}
\NormalTok{        pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]][[}\StringTok{"SearchColumns"}\NormalTok{]] <-}\StringTok{ }\NormalTok{search}
\NormalTok{    \})}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Note the use of \texttt{callNextMethod()} to ensure that observers of the parent class are created.
We also set \texttt{ignoreInit=TRUE} to avoid problems from \texttt{ignoreNULL=TRUE} when the observer is initialized before the table is rendered; otherwise, the \texttt{NULL} selection prior to table rendering will wipe out any initial setting for the \texttt{Selected} slot.

We set up a rendering expression for the output table by specializing \texttt{.renderOutput()}.
This uses the \texttt{renderDataTable()} function from the \emph{\href{https://CRAN.R-project.org/package=DT}{DT}} package
(again, this has a similar-but-not-identical function in \emph{\href{https://CRAN.R-project.org/package=shiny}{shiny}}, so be careful which one you import.)
Some effort is involved in making sure that the output table responds to the memorized parameter values of our \texttt{GOTable} panel.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".renderOutput"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, se, ..., output, pObjects, rObjects) \{}
    \KeywordTok{callNextMethod}\NormalTok{()}

\NormalTok{    panel_name <-}\StringTok{ }\KeywordTok{.getEncodedName}\NormalTok{(x)}
\NormalTok{    output[[panel_name]] <-}\StringTok{ }\NormalTok{DT}\OperatorTok{::}\KeywordTok{renderDataTable}\NormalTok{(\{}
        \KeywordTok{.trackUpdate}\NormalTok{(panel_name, rObjects)}
\NormalTok{        param_choices <-}\StringTok{ }\NormalTok{pObjects}\OperatorTok{$}\NormalTok{memory[[panel_name]]}

\NormalTok{        t.out <-}\StringTok{ }\KeywordTok{.retrieveOutput}\NormalTok{(panel_name, se, pObjects, rObjects)}
\NormalTok{        full_tab <-}\StringTok{ }\NormalTok{t.out}\OperatorTok{$}\NormalTok{contents}\OperatorTok{$}\NormalTok{table}

\NormalTok{        chosen <-}\StringTok{ }\NormalTok{param_choices[[}\StringTok{"Selected"}\NormalTok{]]}
\NormalTok{        search <-}\StringTok{ }\NormalTok{param_choices[[}\StringTok{"Search"}\NormalTok{]]}
\NormalTok{        search_col <-}\StringTok{ }\NormalTok{param_choices[[}\StringTok{"SearchColumns"}\NormalTok{]]}
\NormalTok{        search_col <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(search_col, }\DataTypeTok{FUN=}\ControlFlowTok{function}\NormalTok{(x) \{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{search=}\NormalTok{x) \})}

        \CommentTok{# If the existing row in memory doesn't exist in the current table, we}
        \CommentTok{# don't initialize it with any selection.}
\NormalTok{        idx <-}\StringTok{ }\KeywordTok{which}\NormalTok{(}\KeywordTok{rownames}\NormalTok{(full_tab)}\OperatorTok{==}\NormalTok{chosen)[}\DecValTok{1}\NormalTok{]}
        \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(idx)) \{}
\NormalTok{            selection <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{mode=}\StringTok{"single"}\NormalTok{, }\DataTypeTok{selected=}\NormalTok{idx)}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            selection <-}\StringTok{ "single"}
\NormalTok{        \}}

\NormalTok{        DT}\OperatorTok{::}\KeywordTok{datatable}\NormalTok{(}
\NormalTok{            full_tab, }\DataTypeTok{filter=}\StringTok{"top"}\NormalTok{, }\DataTypeTok{rownames=}\OtherTok{TRUE}\NormalTok{,}
            \DataTypeTok{options=}\KeywordTok{list}\NormalTok{(}
                \DataTypeTok{search=}\KeywordTok{list}\NormalTok{(}\DataTypeTok{search=}\NormalTok{search, }\DataTypeTok{smart=}\OtherTok{FALSE}\NormalTok{, }\DataTypeTok{regex=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{caseInsensitive=}\OtherTok{FALSE}\NormalTok{),}
                \DataTypeTok{searchCols=}\KeywordTok{c}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\OtherTok{NULL}\NormalTok{), search_col), }\CommentTok{# row names are the first column!}
                \DataTypeTok{scrollX=}\OtherTok{TRUE}\NormalTok{),}
            \DataTypeTok{selection=}\NormalTok{selection}
\NormalTok{        )}
\NormalTok{    \})}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{handling-selections}{%
\section{Handling selections}\label{handling-selections}}

Now for the most important bit - configuring the \texttt{GOTable} to transmit a multiple row selection to other panels.
This is achieved by specializing a series of \texttt{.multiSelection*()} methods.
The first is the \texttt{.multiSelectionDimension()}, which controls the dimension being transmitted:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionDimension"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"row"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The next most important method is the \texttt{.multiSelectionCommands()}, which tells \texttt{iSEE()} how to create the multiple row selection from the selected \texttt{DataTable} row.
It is expected to return a vector of commands that, when evaluated, creates a character vector of row names for transmission.
This has an option (\texttt{index}) to differentiate between active and saved selections, though the latter case is not relevant to our \texttt{GOTable} so we will simply ignore it.
We also need to protect against cases where the requested GO term is not found, upon which we simply return an empty character vector.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionCommands"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, index) \{}
\NormalTok{    orgdb <-}\StringTok{ }\NormalTok{x[[}\StringTok{"Organism"}\NormalTok{]]}
\NormalTok{    type <-}\StringTok{ }\NormalTok{x[[}\StringTok{"IDType"}\NormalTok{]]}
    \KeywordTok{c}\NormalTok{(}
        \KeywordTok{sprintf}\NormalTok{(}\StringTok{"require(%s);"}\NormalTok{, orgdb),}
        \KeywordTok{sprintf}\NormalTok{(}\StringTok{"selected <- tryCatch(select(%s, keys=%s, keytype='GO', }
\StringTok{    column=%s)$SYMBOL, error=function(e) character(0));"}\NormalTok{, }
\NormalTok{            orgdb, }\KeywordTok{deparse}\NormalTok{(x[[}\StringTok{"Selected"}\NormalTok{]]), }\KeywordTok{deparse}\NormalTok{(type)),}
        \StringTok{"selected <- intersect(selected, rownames(se));"}
\NormalTok{    )}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We also define some generics to indicate whether a \texttt{DataTable} row is currently selected, and how to delete that selection.
For the latter, we replace the selected row with an empty string to indicate that no selection has been made,
consistent with the actions of our observer in \texttt{.createObservers()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionActive"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
    \ControlFlowTok{if}\NormalTok{ (x[[}\StringTok{"Selected"}\NormalTok{]]}\OperatorTok{!=}\StringTok{""}\NormalTok{) \{}
\NormalTok{        x[[}\StringTok{"Selected"}\NormalTok{]]}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \OtherTok{NULL}
\NormalTok{    \}}
\NormalTok{\})}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionClear"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    x[[}\StringTok{"Selected"}\NormalTok{]] <-}\StringTok{ ""}
\NormalTok{    x}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Finally, we define a method to determine the total number of available genes.
The default is to use the number of rows of the \texttt{data.frame} used in the \texttt{datatable()} call,
but that would not be right for us as it represents the number of gene sets.
Instead, we use the availability information that we previously stored in the \texttt{contents} during \texttt{.generateOutput()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{".multiSelectionAvailable"}\NormalTok{, }\StringTok{"GOTable"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, contents) \{}
\NormalTok{    contents}\OperatorTok{$}\NormalTok{available}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{in-action}{%
\section{In action}\label{in-action}}

Let's put our new panel to the test using the \texttt{sce} object from Chapter \ref{developing}.
We set up an \texttt{iSEE} instance where clicking on any row in the \texttt{GOTable} will subset \texttt{RowTable1} to only those genes in the corresponding GO term.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got <-}\StringTok{ }\KeywordTok{GOTable}\NormalTok{(}\DataTypeTok{PanelWidth=}\NormalTok{8L, }\DataTypeTok{Selected=}\StringTok{"GO:0007049"}\NormalTok{, }\DataTypeTok{Search=}\StringTok{"^cell cycle"}\NormalTok{)}
\NormalTok{rst <-}\StringTok{ }\KeywordTok{RowDataTable}\NormalTok{(}\DataTypeTok{RowSelectionSource=}\StringTok{"GOTable1"}\NormalTok{)}
\NormalTok{app <-}\StringTok{ }\KeywordTok{iSEE}\NormalTok{(sce, }\DataTypeTok{initial=}\KeywordTok{list}\NormalTok{(got, rst))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=1\linewidth]{screenshots/go-table}

\hypertarget{part-appendix}{%
\part{Appendix}\label{part-appendix}}

\hypertarget{contributors}{%
\chapter{Contributors}\label{contributors}}

\hypertarget{aaron-lun}{%
\subsection*{\texorpdfstring{\emph{Aaron Lun}}{Aaron Lun}}\label{aaron-lun}}
\addcontentsline{toc}{subsection}{\emph{Aaron Lun}}

187 days of anime watched.
Nuff said.

\hypertarget{kevin-rue-albrecht}{%
\subsection*{\texorpdfstring{\emph{Kevin Rue-Albrecht}}{Kevin Rue-Albrecht}}\label{kevin-rue-albrecht}}
\addcontentsline{toc}{subsection}{\emph{Kevin Rue-Albrecht}}

Je n'en crois pas mes yeux!

  \bibliography{book.bib,packages.bib}

\end{document}
