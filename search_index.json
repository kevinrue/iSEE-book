[
["index.html", "Extending iSEE Preface", " Extending iSEE Kevin Rue-Albrecht, Federico Marini, Charlotte Soneson, and Aaron Lun 2020-07-08 Preface The Bioconductor package iSEE provides functions to create an interactive graphical user interface (GUI) using the RStudio Shiny package for exploring data stored in SummarizedExperiment objects (Rue-Albrecht et al. 2018). This book describes how to use iSEE’s application programming interface (API) to develop new panel types for custom visualizations. We also present case studies to illustrate the development process for a variety of custom panels. The contents of this book are intended for developers of custom panel classes, usually inside a dedicated package like iSEEu. Potential end-users of iSEE should refer to the vignettes provided on the package landing page. References "],
["panels.html", "Chapter 1 Panel classes 1.1 Overview 1.2 Virtual classes 1.3 Concrete classes", " Chapter 1 Panel classes 1.1 Overview This chapter provides a list of all of the classes that are implemented by the core iSEE package. Each class comes with its specialized implementations of methods for various generics described in Chapter 2. Thus, it is often possible for developers to inherit from one of these classes to get most of the methods implemented “for free”. The classes themselves are either virtual or concrete; the latter can be created and used directly in an iSEE() application, while the former can only be used as a parent of a concrete subclass. Here, we will provide a brief summary of each class along with a listing of its available slots. Readers should refer to the documentation for each class (links below) for more details. 1.2 Virtual classes 1.2.1 Panel The Panel class is the base class for all iSEE panels. It provides functionality to control general panel parameters such as the panel width and height. It also controls the transmission of multiple row/column selections across panels. slotNames(getClass(&quot;Panel&quot;)) ## [1] &quot;PanelId&quot; &quot;PanelHeight&quot; ## [3] &quot;PanelWidth&quot; &quot;SelectionBoxOpen&quot; ## [5] &quot;RowSelectionSource&quot; &quot;ColumnSelectionSource&quot; ## [7] &quot;DataBoxOpen&quot; &quot;RowSelectionDynamicSource&quot; ## [9] &quot;RowSelectionType&quot; &quot;RowSelectionSaved&quot; ## [11] &quot;ColumnSelectionDynamicSource&quot; &quot;ColumnSelectionType&quot; ## [13] &quot;ColumnSelectionSaved&quot; &quot;SelectionHistory&quot; 1.2.2 DotPlot The DotPlot class inherits from the Panel class and is the base class for dot-based plots. This refers to all plots where each row or column is represented by no more than one dot/point on the plot. It provides functionality to create the plot, control the aesthetics of the points and to manage the brush/lasso selection. slotNames(getClass(&quot;DotPlot&quot;)) ## [1] &quot;FacetByRow&quot; &quot;FacetByColumn&quot; ## [3] &quot;ColorBy&quot; &quot;ColorByDefaultColor&quot; ## [5] &quot;ColorByFeatureName&quot; &quot;ColorByFeatureSource&quot; ## [7] &quot;ColorByFeatureDynamicSource&quot; &quot;ColorBySampleName&quot; ## [9] &quot;ColorBySampleSource&quot; &quot;ColorBySampleDynamicSource&quot; ## [11] &quot;ShapeBy&quot; &quot;SizeBy&quot; ## [13] &quot;SelectionEffect&quot; &quot;SelectionColor&quot; ## [15] &quot;SelectionAlpha&quot; &quot;ZoomData&quot; ## [17] &quot;BrushData&quot; &quot;VisualBoxOpen&quot; ## [19] &quot;VisualChoices&quot; &quot;ContourAdd&quot; ## [21] &quot;ContourColor&quot; &quot;PointSize&quot; ## [23] &quot;PointAlpha&quot; &quot;Downsample&quot; ## [25] &quot;DownsampleResolution&quot; &quot;FontSize&quot; ## [27] &quot;LegendPosition&quot; &quot;PanelId&quot; ## [29] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [31] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [33] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [35] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [37] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [39] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [41] &quot;SelectionHistory&quot; 1.2.3 ColumnDotPlot The ColumnDotPlot class inherits from the DotPlot class and represents all per-column dot plots. This refers to all plots where each column is represented by no more than one dot/point on the plot. It provides functionality to manage colData fields for modifying the plot aesthetics. It is also restricted to receiving and transmitting column identities in single and multiple selections. slotNames(getClass(&quot;ColumnDotPlot&quot;)) ## [1] &quot;ColorByColumnData&quot; &quot;ColorByFeatureNameAssay&quot; ## [3] &quot;ColorBySampleNameColor&quot; &quot;ShapeByColumnData&quot; ## [5] &quot;SizeByColumnData&quot; &quot;FacetByRow&quot; ## [7] &quot;FacetByColumn&quot; &quot;ColorBy&quot; ## [9] &quot;ColorByDefaultColor&quot; &quot;ColorByFeatureName&quot; ## [11] &quot;ColorByFeatureSource&quot; &quot;ColorByFeatureDynamicSource&quot; ## [13] &quot;ColorBySampleName&quot; &quot;ColorBySampleSource&quot; ## [15] &quot;ColorBySampleDynamicSource&quot; &quot;ShapeBy&quot; ## [17] &quot;SizeBy&quot; &quot;SelectionEffect&quot; ## [19] &quot;SelectionColor&quot; &quot;SelectionAlpha&quot; ## [21] &quot;ZoomData&quot; &quot;BrushData&quot; ## [23] &quot;VisualBoxOpen&quot; &quot;VisualChoices&quot; ## [25] &quot;ContourAdd&quot; &quot;ContourColor&quot; ## [27] &quot;PointSize&quot; &quot;PointAlpha&quot; ## [29] &quot;Downsample&quot; &quot;DownsampleResolution&quot; ## [31] &quot;FontSize&quot; &quot;LegendPosition&quot; ## [33] &quot;PanelId&quot; &quot;PanelHeight&quot; ## [35] &quot;PanelWidth&quot; &quot;SelectionBoxOpen&quot; ## [37] &quot;RowSelectionSource&quot; &quot;ColumnSelectionSource&quot; ## [39] &quot;DataBoxOpen&quot; &quot;RowSelectionDynamicSource&quot; ## [41] &quot;RowSelectionType&quot; &quot;RowSelectionSaved&quot; ## [43] &quot;ColumnSelectionDynamicSource&quot; &quot;ColumnSelectionType&quot; ## [45] &quot;ColumnSelectionSaved&quot; &quot;SelectionHistory&quot; 1.2.4 RowDotPlot The RowDotPlot class inherits from the DotPlot class and represents all per-row dot plots. This refers to all plots where each row is represented by no more than one dot/point on the plot. It provides functionality to manage rowData fields for modifying the plot aesthetics. It is also restricted to receiving and transmitting row identities in single and multiple selections. slotNames(getClass(&quot;RowDotPlot&quot;)) ## [1] &quot;ColorByRowData&quot; &quot;ColorBySampleNameAssay&quot; ## [3] &quot;ColorByFeatureNameColor&quot; &quot;ShapeByRowData&quot; ## [5] &quot;SizeByRowData&quot; &quot;FacetByRow&quot; ## [7] &quot;FacetByColumn&quot; &quot;ColorBy&quot; ## [9] &quot;ColorByDefaultColor&quot; &quot;ColorByFeatureName&quot; ## [11] &quot;ColorByFeatureSource&quot; &quot;ColorByFeatureDynamicSource&quot; ## [13] &quot;ColorBySampleName&quot; &quot;ColorBySampleSource&quot; ## [15] &quot;ColorBySampleDynamicSource&quot; &quot;ShapeBy&quot; ## [17] &quot;SizeBy&quot; &quot;SelectionEffect&quot; ## [19] &quot;SelectionColor&quot; &quot;SelectionAlpha&quot; ## [21] &quot;ZoomData&quot; &quot;BrushData&quot; ## [23] &quot;VisualBoxOpen&quot; &quot;VisualChoices&quot; ## [25] &quot;ContourAdd&quot; &quot;ContourColor&quot; ## [27] &quot;PointSize&quot; &quot;PointAlpha&quot; ## [29] &quot;Downsample&quot; &quot;DownsampleResolution&quot; ## [31] &quot;FontSize&quot; &quot;LegendPosition&quot; ## [33] &quot;PanelId&quot; &quot;PanelHeight&quot; ## [35] &quot;PanelWidth&quot; &quot;SelectionBoxOpen&quot; ## [37] &quot;RowSelectionSource&quot; &quot;ColumnSelectionSource&quot; ## [39] &quot;DataBoxOpen&quot; &quot;RowSelectionDynamicSource&quot; ## [41] &quot;RowSelectionType&quot; &quot;RowSelectionSaved&quot; ## [43] &quot;ColumnSelectionDynamicSource&quot; &quot;ColumnSelectionType&quot; ## [45] &quot;ColumnSelectionSaved&quot; &quot;SelectionHistory&quot; 1.2.5 Table The Table class inherits from the Panel class and represents all tables rendered using DT. Each row of the table is expected to correspond to a row or column of the SummarizedExperiment. This class provides functionality to render the DT::datatable widget, monitor single selections and apply search filters. slotNames(getClass(&quot;Table&quot;)) ## [1] &quot;Selected&quot; &quot;Search&quot; ## [3] &quot;SearchColumns&quot; &quot;PanelId&quot; ## [5] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [7] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [9] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [11] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [13] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [15] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [17] &quot;SelectionHistory&quot; 1.2.6 ColumnTable The ColumnTable class inherits from the Table class and represents all tables where the rows correspond to columns of the SummarizedExperiment. Instances of this class can only transmit single and multiple selections on columns. slotNames(getClass(&quot;ColumnTable&quot;)) ## [1] &quot;Selected&quot; &quot;Search&quot; ## [3] &quot;SearchColumns&quot; &quot;PanelId&quot; ## [5] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [7] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [9] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [11] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [13] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [15] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [17] &quot;SelectionHistory&quot; 1.2.7 RowTable The RowTable class inherits from the Table class and represents all tables where the rows correspond to rows of the SummarizedExperiment. Instances of this class can only transmit single and multiple selections on rows. slotNames(getClass(&quot;RowTable&quot;)) ## [1] &quot;Selected&quot; &quot;Search&quot; ## [3] &quot;SearchColumns&quot; &quot;PanelId&quot; ## [5] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [7] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [9] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [11] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [13] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [15] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [17] &quot;SelectionHistory&quot; 1.3 Concrete classes 1.3.1 ReducedDimensionPlot The ReducedDimensionPlot class inherits from the ColumnDotPlot class and plots reduced dimension coordinates from an entry of the reducedDims in a SingleCellExperiment. It provides functionality to choose the result and extract the relevant entry in preparation for plotting. slotNames(getClass(&quot;ReducedDimensionPlot&quot;)) ## [1] &quot;Type&quot; &quot;XAxis&quot; ## [3] &quot;YAxis&quot; &quot;ColorByColumnData&quot; ## [5] &quot;ColorByFeatureNameAssay&quot; &quot;ColorBySampleNameColor&quot; ## [7] &quot;ShapeByColumnData&quot; &quot;SizeByColumnData&quot; ## [9] &quot;FacetByRow&quot; &quot;FacetByColumn&quot; ## [11] &quot;ColorBy&quot; &quot;ColorByDefaultColor&quot; ## [13] &quot;ColorByFeatureName&quot; &quot;ColorByFeatureSource&quot; ## [15] &quot;ColorByFeatureDynamicSource&quot; &quot;ColorBySampleName&quot; ## [17] &quot;ColorBySampleSource&quot; &quot;ColorBySampleDynamicSource&quot; ## [19] &quot;ShapeBy&quot; &quot;SizeBy&quot; ## [21] &quot;SelectionEffect&quot; &quot;SelectionColor&quot; ## [23] &quot;SelectionAlpha&quot; &quot;ZoomData&quot; ## [25] &quot;BrushData&quot; &quot;VisualBoxOpen&quot; ## [27] &quot;VisualChoices&quot; &quot;ContourAdd&quot; ## [29] &quot;ContourColor&quot; &quot;PointSize&quot; ## [31] &quot;PointAlpha&quot; &quot;Downsample&quot; ## [33] &quot;DownsampleResolution&quot; &quot;FontSize&quot; ## [35] &quot;LegendPosition&quot; &quot;PanelId&quot; ## [37] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [39] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [41] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [43] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [45] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [47] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [49] &quot;SelectionHistory&quot; 1.3.2 FeatureAssayPlot The FeatureAssayPlot class inherits from the ColumnDotPlot class and plots the assay values for a feature across all samples, using an entry of the assays() from any SummarizedExperiment object. It provides functionality to choose the feature of interest and any associated variable to plot on the x-axis, as well as a method to extract the relevant pieces of data in preparation for plotting. slotNames(getClass(&quot;FeatureAssayPlot&quot;)) ## [1] &quot;Assay&quot; &quot;XAxis&quot; ## [3] &quot;XAxisColumnData&quot; &quot;XAxisFeatureName&quot; ## [5] &quot;XAxisFeatureSource&quot; &quot;XAxisFeatureDynamicSource&quot; ## [7] &quot;YAxisFeatureName&quot; &quot;YAxisFeatureSource&quot; ## [9] &quot;YAxisFeatureDynamicSource&quot; &quot;ColorByColumnData&quot; ## [11] &quot;ColorByFeatureNameAssay&quot; &quot;ColorBySampleNameColor&quot; ## [13] &quot;ShapeByColumnData&quot; &quot;SizeByColumnData&quot; ## [15] &quot;FacetByRow&quot; &quot;FacetByColumn&quot; ## [17] &quot;ColorBy&quot; &quot;ColorByDefaultColor&quot; ## [19] &quot;ColorByFeatureName&quot; &quot;ColorByFeatureSource&quot; ## [21] &quot;ColorByFeatureDynamicSource&quot; &quot;ColorBySampleName&quot; ## [23] &quot;ColorBySampleSource&quot; &quot;ColorBySampleDynamicSource&quot; ## [25] &quot;ShapeBy&quot; &quot;SizeBy&quot; ## [27] &quot;SelectionEffect&quot; &quot;SelectionColor&quot; ## [29] &quot;SelectionAlpha&quot; &quot;ZoomData&quot; ## [31] &quot;BrushData&quot; &quot;VisualBoxOpen&quot; ## [33] &quot;VisualChoices&quot; &quot;ContourAdd&quot; ## [35] &quot;ContourColor&quot; &quot;PointSize&quot; ## [37] &quot;PointAlpha&quot; &quot;Downsample&quot; ## [39] &quot;DownsampleResolution&quot; &quot;FontSize&quot; ## [41] &quot;LegendPosition&quot; &quot;PanelId&quot; ## [43] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [45] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [47] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [49] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [51] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [53] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [55] &quot;SelectionHistory&quot; 1.3.3 ColumnDataPlot The ColumnDataPlot class inherits from the ColumnDotPlot class and plots colData variables by themselves or against each other. It provides functionality to choose and extract the variables to plot. slotNames(getClass(&quot;ColumnDataPlot&quot;)) ## [1] &quot;XAxis&quot; &quot;YAxis&quot; ## [3] &quot;XAxisColumnData&quot; &quot;ColorByColumnData&quot; ## [5] &quot;ColorByFeatureNameAssay&quot; &quot;ColorBySampleNameColor&quot; ## [7] &quot;ShapeByColumnData&quot; &quot;SizeByColumnData&quot; ## [9] &quot;FacetByRow&quot; &quot;FacetByColumn&quot; ## [11] &quot;ColorBy&quot; &quot;ColorByDefaultColor&quot; ## [13] &quot;ColorByFeatureName&quot; &quot;ColorByFeatureSource&quot; ## [15] &quot;ColorByFeatureDynamicSource&quot; &quot;ColorBySampleName&quot; ## [17] &quot;ColorBySampleSource&quot; &quot;ColorBySampleDynamicSource&quot; ## [19] &quot;ShapeBy&quot; &quot;SizeBy&quot; ## [21] &quot;SelectionEffect&quot; &quot;SelectionColor&quot; ## [23] &quot;SelectionAlpha&quot; &quot;ZoomData&quot; ## [25] &quot;BrushData&quot; &quot;VisualBoxOpen&quot; ## [27] &quot;VisualChoices&quot; &quot;ContourAdd&quot; ## [29] &quot;ContourColor&quot; &quot;PointSize&quot; ## [31] &quot;PointAlpha&quot; &quot;Downsample&quot; ## [33] &quot;DownsampleResolution&quot; &quot;FontSize&quot; ## [35] &quot;LegendPosition&quot; &quot;PanelId&quot; ## [37] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [39] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [41] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [43] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [45] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [47] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [49] &quot;SelectionHistory&quot; 1.3.4 SampleAssayPlot The SampleAssayPlot class inherits from the RowDotPlot class and plots the assay values for a sample across all features, using an entry of the assays() from any SummarizedExperiment object. It provides functionality to choose the sample of interest and any associated variable to plot on the x-axis, as well as a method to extract the relevant pieces of data in preparation for plotting. slotNames(getClass(&quot;FeatureAssayPlot&quot;)) ## [1] &quot;Assay&quot; &quot;XAxis&quot; ## [3] &quot;XAxisColumnData&quot; &quot;XAxisFeatureName&quot; ## [5] &quot;XAxisFeatureSource&quot; &quot;XAxisFeatureDynamicSource&quot; ## [7] &quot;YAxisFeatureName&quot; &quot;YAxisFeatureSource&quot; ## [9] &quot;YAxisFeatureDynamicSource&quot; &quot;ColorByColumnData&quot; ## [11] &quot;ColorByFeatureNameAssay&quot; &quot;ColorBySampleNameColor&quot; ## [13] &quot;ShapeByColumnData&quot; &quot;SizeByColumnData&quot; ## [15] &quot;FacetByRow&quot; &quot;FacetByColumn&quot; ## [17] &quot;ColorBy&quot; &quot;ColorByDefaultColor&quot; ## [19] &quot;ColorByFeatureName&quot; &quot;ColorByFeatureSource&quot; ## [21] &quot;ColorByFeatureDynamicSource&quot; &quot;ColorBySampleName&quot; ## [23] &quot;ColorBySampleSource&quot; &quot;ColorBySampleDynamicSource&quot; ## [25] &quot;ShapeBy&quot; &quot;SizeBy&quot; ## [27] &quot;SelectionEffect&quot; &quot;SelectionColor&quot; ## [29] &quot;SelectionAlpha&quot; &quot;ZoomData&quot; ## [31] &quot;BrushData&quot; &quot;VisualBoxOpen&quot; ## [33] &quot;VisualChoices&quot; &quot;ContourAdd&quot; ## [35] &quot;ContourColor&quot; &quot;PointSize&quot; ## [37] &quot;PointAlpha&quot; &quot;Downsample&quot; ## [39] &quot;DownsampleResolution&quot; &quot;FontSize&quot; ## [41] &quot;LegendPosition&quot; &quot;PanelId&quot; ## [43] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [45] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [47] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [49] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [51] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [53] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [55] &quot;SelectionHistory&quot; 1.3.5 RowDataPlot The RowDataPlot class inherits from the RowDotPlot class and plots rowData variables by themselves or against each other. It provides functionality to choose and extract the variables to plot. slotNames(getClass(&quot;RowDataPlot&quot;)) ## [1] &quot;XAxis&quot; &quot;YAxis&quot; ## [3] &quot;XAxisRowData&quot; &quot;ColorByRowData&quot; ## [5] &quot;ColorBySampleNameAssay&quot; &quot;ColorByFeatureNameColor&quot; ## [7] &quot;ShapeByRowData&quot; &quot;SizeByRowData&quot; ## [9] &quot;FacetByRow&quot; &quot;FacetByColumn&quot; ## [11] &quot;ColorBy&quot; &quot;ColorByDefaultColor&quot; ## [13] &quot;ColorByFeatureName&quot; &quot;ColorByFeatureSource&quot; ## [15] &quot;ColorByFeatureDynamicSource&quot; &quot;ColorBySampleName&quot; ## [17] &quot;ColorBySampleSource&quot; &quot;ColorBySampleDynamicSource&quot; ## [19] &quot;ShapeBy&quot; &quot;SizeBy&quot; ## [21] &quot;SelectionEffect&quot; &quot;SelectionColor&quot; ## [23] &quot;SelectionAlpha&quot; &quot;ZoomData&quot; ## [25] &quot;BrushData&quot; &quot;VisualBoxOpen&quot; ## [27] &quot;VisualChoices&quot; &quot;ContourAdd&quot; ## [29] &quot;ContourColor&quot; &quot;PointSize&quot; ## [31] &quot;PointAlpha&quot; &quot;Downsample&quot; ## [33] &quot;DownsampleResolution&quot; &quot;FontSize&quot; ## [35] &quot;LegendPosition&quot; &quot;PanelId&quot; ## [37] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [39] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [41] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [43] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [45] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [47] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [49] &quot;SelectionHistory&quot; 1.3.6 ColumnDataTable The ColumnDataTable class inherits from the ColumnTable class and shows the contents of the colData in a table. It provides functionality to extract the colData in preparation for rendering. slotNames(getClass(&quot;ColumnDataTable&quot;)) ## [1] &quot;Selected&quot; &quot;Search&quot; ## [3] &quot;SearchColumns&quot; &quot;PanelId&quot; ## [5] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [7] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [9] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [11] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [13] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [15] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [17] &quot;SelectionHistory&quot; 1.3.7 RowDataTable The RowDataTable class inherits from the RowTable class and shows the contents of the rowData in a table. It provides functionality to extract the rowData in preparation for rendering. slotNames(getClass(&quot;RowDataTable&quot;)) ## [1] &quot;Selected&quot; &quot;Search&quot; ## [3] &quot;SearchColumns&quot; &quot;PanelId&quot; ## [5] &quot;PanelHeight&quot; &quot;PanelWidth&quot; ## [7] &quot;SelectionBoxOpen&quot; &quot;RowSelectionSource&quot; ## [9] &quot;ColumnSelectionSource&quot; &quot;DataBoxOpen&quot; ## [11] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [13] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [15] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [17] &quot;SelectionHistory&quot; 1.3.8 ComplexHeatmapPlot The ComplexHeatmapPlot class inherits from the Panel class and creates a heatmap from assay values using the ComplexHeatmap package. It provides functionality to specify the features to be shown, which assay to show, transformations to be applied, and which metadata variables to display as row and column heatmap annotations. slotNames(getClass(&quot;ComplexHeatmapPlot&quot;)) ## [1] &quot;Assay&quot; &quot;CustomRows&quot; ## [3] &quot;CustomRowsText&quot; &quot;ClusterRows&quot; ## [5] &quot;ClusterRowsDistance&quot; &quot;ClusterRowsMethod&quot; ## [7] &quot;DataBoxOpen&quot; &quot;VisualChoices&quot; ## [9] &quot;ColumnData&quot; &quot;RowData&quot; ## [11] &quot;CustomBounds&quot; &quot;LowerBound&quot; ## [13] &quot;UpperBound&quot; &quot;AssayCenterRows&quot; ## [15] &quot;AssayScaleRows&quot; &quot;DivergentColormap&quot; ## [17] &quot;ShowDimNames&quot; &quot;LegendPosition&quot; ## [19] &quot;LegendDirection&quot; &quot;VisualBoxOpen&quot; ## [21] &quot;SelectionEffect&quot; &quot;SelectionColor&quot; ## [23] &quot;PanelId&quot; &quot;PanelHeight&quot; ## [25] &quot;PanelWidth&quot; &quot;SelectionBoxOpen&quot; ## [27] &quot;RowSelectionSource&quot; &quot;ColumnSelectionSource&quot; ## [29] &quot;RowSelectionDynamicSource&quot; &quot;RowSelectionType&quot; ## [31] &quot;RowSelectionSaved&quot; &quot;ColumnSelectionDynamicSource&quot; ## [33] &quot;ColumnSelectionType&quot; &quot;ColumnSelectionSaved&quot; ## [35] &quot;SelectionHistory&quot; "],
["api.html", "Chapter 2 Panel generics 2.1 Overview 2.2 Parameter set-up 2.3 Defining the user interface 2.4 Creating observers 2.5 Defining panel outputs 2.6 Handling selections", " Chapter 2 Panel generics 2.1 Overview This chapter lists of all generics provided by iSEE to implement class-specific behaviors. For each generic, we will show its signature and all available methods implemented for subclasses. Do not be intimidated; it is rare that it is necessary to define methods for all of the generics shown here. If your class inherits from an existing Panel subclass, many of these methods will be implemented for free, and all you have to do is to override a handful of methods to achieve the desired customization. We recommend skimming over this chapter on the first read to get a feel for the available entry points into the Panel API. Once you have a better idea of what your class needs to do, you can obtain exhaustive documentation about each generic in the usual way, e.g., ?.defineInterface. 2.2 Parameter set-up .cacheCommonInfo() caches common values to be used for all instances of a particular panel class. These cached values can be used to, e.g., populate the UI or set up constants to be used in the panel’s output. This avoids potentially costly re-calculations throughout the lifetime of the iSEE() application. getGeneric(&quot;.cacheCommonInfo&quot;) ## standardGeneric for &quot;.cacheCommonInfo&quot; defined from package &quot;iSEE&quot; ## ## function (x, se) ## standardGeneric(&quot;.cacheCommonInfo&quot;) ## &lt;bytecode: 0x7f8405b2b110&gt; ## &lt;environment: 0x7f8405b4eae0&gt; ## Methods may be defined for arguments: x, se ## Use showMethods(&quot;.cacheCommonInfo&quot;) for currently available ones. showMethods(&quot;.cacheCommonInfo&quot;) ## Function: .cacheCommonInfo (package iSEE) ## x=&quot;ColumnDataTable&quot; ## x=&quot;ColumnDotPlot&quot; ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;DotPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;ReducedDimensionPlot&quot; ## x=&quot;RowDataTable&quot; ## x=&quot;RowDotPlot&quot; .refineParameters() edits the parameters of a panel to ensure that they are valid. For example, we may need to restrict the choices of a selectize element to some pre-defined possibilities. This is run for each panel during the iSEE() application set-up to validate the user-supplied panel configuration. getGeneric(&quot;.refineParameters&quot;) ## standardGeneric for &quot;.refineParameters&quot; defined from package &quot;iSEE&quot; ## ## function (x, se) ## standardGeneric(&quot;.refineParameters&quot;) ## &lt;bytecode: 0x7f8405906cd8&gt; ## &lt;environment: 0x7f840594c168&gt; ## Methods may be defined for arguments: x, se ## Use showMethods(&quot;.refineParameters&quot;) for currently available ones. showMethods(&quot;.refineParameters&quot;) ## Function: .refineParameters (package iSEE) ## x=&quot;ColumnDataPlot&quot; ## x=&quot;ColumnDataTable&quot; ## x=&quot;ColumnDotPlot&quot; ## x=&quot;ColumnTable&quot; ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;DotPlot&quot; ## x=&quot;FeatureAssayPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;ReducedDimensionPlot&quot; ## x=&quot;RowDataPlot&quot; ## x=&quot;RowDataTable&quot; ## x=&quot;RowDotPlot&quot; ## x=&quot;RowTable&quot; ## x=&quot;SampleAssayPlot&quot; 2.3 Defining the user interface 2.3.1 In general .defineInterface() defines the user interface (UI) for a panel, defining all HTML widgets required to modify parameters. Parameters should be bundled into collapsible boxes according to their approximate purpose. This generic provides the most general mechanism for controlling the panel’s interface. getGeneric(&quot;.defineInterface&quot;) ## standardGeneric for &quot;.defineInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x, se, select_info) ## standardGeneric(&quot;.defineInterface&quot;) ## &lt;bytecode: 0x7f8408091918&gt; ## &lt;environment: 0x7f84080a0360&gt; ## Methods may be defined for arguments: x, se, select_info ## Use showMethods(&quot;.defineInterface&quot;) for currently available ones. showMethods(&quot;.defineInterface&quot;) ## Function: .defineInterface (package iSEE) ## x=&quot;ColumnDotPlot&quot; ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;RowDotPlot&quot; .defineDataInterface() defines the UI for modifying all data-related parameters in a given panel. Such parameters are fundamental to the interpretation of the panel’s output, as opposed to their aesthetic counterparts. This generic allows developers to fine-tune the data UI for subclasses without reimplementing the parent class’ .defineInterface(), especially if we wish to re-use the parent’s UI for aesthetic parameters. getGeneric(&quot;.defineDataInterface&quot;) ## standardGeneric for &quot;.defineDataInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x, se, select_info) ## standardGeneric(&quot;.defineDataInterface&quot;) ## &lt;bytecode: 0x7f84080e7000&gt; ## &lt;environment: 0x7f840811d820&gt; ## Methods may be defined for arguments: x, se, select_info ## Use showMethods(&quot;.defineDataInterface&quot;) for currently available ones. showMethods(&quot;.defineDataInterface&quot;) ## Function: .defineDataInterface (package iSEE) ## x=&quot;ColumnDataPlot&quot; ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;FeatureAssayPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;ReducedDimensionPlot&quot; ## x=&quot;RowDataPlot&quot; ## x=&quot;SampleAssayPlot&quot; .hideInterface() determines whether certain UI elements should be hidden from the user. This allows subclasses to hide easily inappropriate or irrelevant parts of the parent’s UI without redefining .defineInterface(). For example, we can remove row selection UI elements for panels that only accept column selections. getGeneric(&quot;.hideInterface&quot;) ## standardGeneric for &quot;.hideInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x, field) ## standardGeneric(&quot;.hideInterface&quot;) ## &lt;bytecode: 0x7f8406aff508&gt; ## &lt;environment: 0x7f8406b111c8&gt; ## Methods may be defined for arguments: x, field ## Use showMethods(&quot;.hideInterface&quot;) for currently available ones. showMethods(&quot;.hideInterface&quot;) ## Function: .hideInterface (package iSEE) ## x=&quot;ColumnDataTable&quot; ## x=&quot;ColumnDotPlot&quot; ## x=&quot;ColumnTable&quot; ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;RowDataTable&quot; ## x=&quot;RowDotPlot&quot; ## x=&quot;RowTable&quot; ## x=&quot;Table&quot; 2.3.2 The DotPlot visual interface .defineVisualColorInterface() defines the UI for color-related visual parameters in a DotPlot subclass. getGeneric(&quot;.defineVisualColorInterface&quot;) ## standardGeneric for &quot;.defineVisualColorInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x, se, select_info) ## standardGeneric(&quot;.defineVisualColorInterface&quot;) ## &lt;bytecode: 0x7f84074ff9c8&gt; ## &lt;environment: 0x7f8407522a70&gt; ## Methods may be defined for arguments: x, se, select_info ## Use showMethods(&quot;.defineVisualColorInterface&quot;) for currently available ones. showMethods(&quot;.defineVisualColorInterface&quot;) ## Function: .defineVisualColorInterface (package iSEE) ## x=&quot;ColumnDotPlot&quot; ## x=&quot;RowDotPlot&quot; .defineVisualFacetInterface() defines the UI for facet-related visual parameters in a DotPlot subclass. getGeneric(&quot;.defineVisualFacetInterface&quot;) ## standardGeneric for &quot;.defineVisualFacetInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x, se) ## standardGeneric(&quot;.defineVisualFacetInterface&quot;) ## &lt;bytecode: 0x7f84074ce760&gt; ## &lt;environment: 0x7f84074da198&gt; ## Methods may be defined for arguments: x, se ## Use showMethods(&quot;.defineVisualFacetInterface&quot;) for currently available ones. showMethods(&quot;.defineVisualFacetInterface&quot;) ## Function: .defineVisualFacetInterface (package iSEE) ## x=&quot;ColumnDotPlot&quot; ## x=&quot;RowDotPlot&quot; .defineVisualShapeInterface() defines the UI for shape-related visual parameters in a DotPlot subclass. getGeneric(&quot;.defineVisualShapeInterface&quot;) ## standardGeneric for &quot;.defineVisualShapeInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x, se) ## standardGeneric(&quot;.defineVisualShapeInterface&quot;) ## &lt;bytecode: 0x7f8406c03628&gt; ## &lt;environment: 0x7f8406c1d9d8&gt; ## Methods may be defined for arguments: x, se ## Use showMethods(&quot;.defineVisualShapeInterface&quot;) for currently available ones. showMethods(&quot;.defineVisualShapeInterface&quot;) ## Function: .defineVisualShapeInterface (package iSEE) ## x=&quot;ColumnDotPlot&quot; ## x=&quot;RowDotPlot&quot; .defineVisualSizeInterface() defines the UI for size-related visual parameters in a DotPlot subclass. getGeneric(&quot;.defineVisualSizeInterface&quot;) ## standardGeneric for &quot;.defineVisualSizeInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x, se) ## standardGeneric(&quot;.defineVisualSizeInterface&quot;) ## &lt;bytecode: 0x7f8406bd48d0&gt; ## &lt;environment: 0x7f8406be72e0&gt; ## Methods may be defined for arguments: x, se ## Use showMethods(&quot;.defineVisualSizeInterface&quot;) for currently available ones. showMethods(&quot;.defineVisualSizeInterface&quot;) ## Function: .defineVisualSizeInterface (package iSEE) ## x=&quot;ColumnDotPlot&quot; ## x=&quot;RowDotPlot&quot; .defineVisualTextInterface() defines the UI for text-related visual parameters in a DotPlot subclass. getGeneric(&quot;.defineVisualTextInterface&quot;) ## standardGeneric for &quot;.defineVisualTextInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x, se) ## standardGeneric(&quot;.defineVisualTextInterface&quot;) ## &lt;bytecode: 0x7f8406badc18&gt; ## &lt;environment: 0x7f8406bb2e50&gt; ## Methods may be defined for arguments: x, se ## Use showMethods(&quot;.defineVisualTextInterface&quot;) for currently available ones. showMethods(&quot;.defineVisualTextInterface&quot;) ## Function: .defineVisualTextInterface (package iSEE) ## x=&quot;DotPlot&quot; .defineVisualOtherInterface() defines the UI for other visual parameters in a DotPlot subclass. getGeneric(&quot;.defineVisualOtherInterface&quot;) ## standardGeneric for &quot;.defineVisualOtherInterface&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.defineVisualOtherInterface&quot;) ## &lt;bytecode: 0x7f84074ad5b0&gt; ## &lt;environment: 0x7f84074b30e0&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.defineVisualOtherInterface&quot;) for currently available ones. showMethods(&quot;.defineVisualOtherInterface&quot;) ## Function: .defineVisualOtherInterface (package iSEE) ## x=&quot;DotPlot&quot; These generics allow developers to change UI elements for a subclass without completely reimplementing .defineInterface(). Of course, if we have already specialized .defineInterface(), then there’s no need to define methods for these generics. 2.4 Creating observers .createObservers() sets up Shiny observers for the current session. This is the workhorse function to ensure that the panel actually responds to user input. Developers can define arbitrarily complex observer logic here as long as it is self-contained within a single panel. (Interactive mechanics that involve communication between panels is handled elsewhere.) getGeneric(&quot;.createObservers&quot;) ## nonstandardGenericFunction for &quot;.createObservers&quot; defined from package &quot;iSEE&quot; ## ## function (x, se, input, session, pObjects, rObjects) ## { ## standardGeneric(&quot;.createObservers&quot;) ## } ## &lt;bytecode: 0x7f8408067750&gt; ## &lt;environment: 0x7f84081cb5d8&gt; ## Methods may be defined for arguments: x, se, input, session, pObjects, rObjects ## Use showMethods(&quot;.createObservers&quot;) for currently available ones. showMethods(&quot;.createObservers&quot;) ## Function: .createObservers (package iSEE) ## x=&quot;ColumnDataPlot&quot; ## x=&quot;ColumnDotPlot&quot; ## x=&quot;ColumnTable&quot; ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;DotPlot&quot; ## x=&quot;FeatureAssayPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;ReducedDimensionPlot&quot; ## x=&quot;RowDataPlot&quot; ## x=&quot;RowDotPlot&quot; ## x=&quot;RowTable&quot; ## x=&quot;SampleAssayPlot&quot; ## x=&quot;Table&quot; 2.5 Defining panel outputs 2.5.1 In general .defineOutput() defines the interface element containing the visual output of the panel. Examples include plotOutput() for plots or dataTableOutput() for tables. Note that this generic only defines the output in the iSEE() interface; it does not control the rendering. getGeneric(&quot;.defineOutput&quot;) ## nonstandardGenericFunction for &quot;.defineOutput&quot; defined from package &quot;iSEE&quot; ## ## function (x, ...) ## { ## standardGeneric(&quot;.defineOutput&quot;) ## } ## &lt;bytecode: 0x7f8408059a28&gt; ## &lt;environment: 0x7f8408062390&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.defineOutput&quot;) for currently available ones. showMethods(&quot;.defineOutput&quot;) ## Function: .defineOutput (package iSEE) ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;DotPlot&quot; ## x=&quot;Table&quot; .renderOutput() assigns a reactive expression to populate the output interface element with content. This is usually as simple as calling functions like renderPlotOutput() with an appropriate rendering expression containing a call to .retrieveOutput(). getGeneric(&quot;.renderOutput&quot;) ## nonstandardGenericFunction for &quot;.renderOutput&quot; defined from package &quot;iSEE&quot; ## ## function (x, se, ..., output, pObjects, rObjects) ## { ## standardGeneric(&quot;.renderOutput&quot;) ## } ## &lt;bytecode: 0x7f8406a73e70&gt; ## &lt;environment: 0x7f8406a83310&gt; ## Methods may be defined for arguments: x, se, output, pObjects, rObjects ## Use showMethods(&quot;.renderOutput&quot;) for currently available ones. showMethods(&quot;.renderOutput&quot;) ## Function: .renderOutput (package iSEE) ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;DotPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;Table&quot; .generateOutput() actually generates the panel output, be it a plot or table or something more exotic. This is usually the real function that does all the work, being called by .retrieveOutput() prior to rendering the output. Some effort is required here to ensure that the commands used to generate the output are also captured. getGeneric(&quot;.generateOutput&quot;) ## nonstandardGenericFunction for &quot;.generateOutput&quot; defined from package &quot;iSEE&quot; ## ## function (x, se, ..., all_memory, all_contents) ## { ## standardGeneric(&quot;.generateOutput&quot;) ## } ## &lt;bytecode: 0x7f8406b717d0&gt; ## &lt;environment: 0x7f8405a379f8&gt; ## Methods may be defined for arguments: x, se, all_memory, all_contents ## Use showMethods(&quot;.generateOutput&quot;) for currently available ones. showMethods(&quot;.generateOutput&quot;) ## Function: .generateOutput (package iSEE) ## x=&quot;ComplexHeatmapPlot&quot; ## x=&quot;DotPlot&quot; ## x=&quot;Table&quot; .exportOutput() converts the panel output into a form that is downloadable, such as a PDF file for plots or CSVs for tables. This is called whenever the user requests a download of the panel outputs. getGeneric(&quot;.exportOutput&quot;) ## nonstandardGenericFunction for &quot;.exportOutput&quot; defined from package &quot;iSEE&quot; ## ## function (x, se, all_memory, all_contents) ## { ## standardGeneric(&quot;.exportOutput&quot;) ## } ## &lt;bytecode: 0x7f8407483da0&gt; ## &lt;environment: 0x7f8407493dc8&gt; ## Methods may be defined for arguments: x, se, all_memory, all_contents ## Use showMethods(&quot;.exportOutput&quot;) for currently available ones. showMethods(&quot;.exportOutput&quot;) ## Function: .exportOutput (package iSEE) ## x=&quot;DotPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;Table&quot; 2.5.2 For DotPlots .generateDotPlot() creates the ggplot object for DotPlot subclasses. This is called internally by the DotPlot method for .generateOutput() to create the relevant output. Developers of DotPlot subclasses can specialize this generic to avoid having to reimplement .generateOutput() (and the associated data management therein). getGeneric(&quot;.generateDotPlot&quot;) ## standardGeneric for &quot;.generateDotPlot&quot; defined from package &quot;iSEE&quot; ## ## function (x, labels, envir) ## standardGeneric(&quot;.generateDotPlot&quot;) ## &lt;bytecode: 0x7f8405aa8df0&gt; ## &lt;environment: 0x7f8405ab84e8&gt; ## Methods may be defined for arguments: x, labels, envir ## Use showMethods(&quot;.generateDotPlot&quot;) for currently available ones. showMethods(&quot;.generateDotPlot&quot;) ## Function: .generateDotPlot (package iSEE) ## x=&quot;DotPlot&quot; .generateDotPlotData() creates the data.frame that is used by .generateDotPlot(). This allows developers to change the data setup for a DotPlot subclass without having to even specialize .generateDotPlot(), provided they are happy with the default DotPlot aesthetics. getGeneric(&quot;.generateDotPlotData&quot;) ## standardGeneric for &quot;.generateDotPlotData&quot; defined from package &quot;iSEE&quot; ## ## function (x, envir) ## standardGeneric(&quot;.generateDotPlotData&quot;) ## &lt;bytecode: 0x7f8405a6ad48&gt; ## &lt;environment: 0x7f8405a8ea00&gt; ## Methods may be defined for arguments: x, envir ## Use showMethods(&quot;.generateDotPlotData&quot;) for currently available ones. showMethods(&quot;.generateDotPlotData&quot;) ## Function: .generateDotPlotData (package iSEE) ## x=&quot;ColumnDataPlot&quot; ## x=&quot;FeatureAssayPlot&quot; ## x=&quot;ReducedDimensionPlot&quot; ## x=&quot;RowDataPlot&quot; ## x=&quot;SampleAssayPlot&quot; .prioritizeDotPlotData() determines how points should be prioritized during overplotting. This usually doesn’t need to be specialized. getGeneric(&quot;.prioritizeDotPlotData&quot;) ## standardGeneric for &quot;.prioritizeDotPlotData&quot; defined from package &quot;iSEE&quot; ## ## function (x, envir) ## standardGeneric(&quot;.prioritizeDotPlotData&quot;) ## &lt;bytecode: 0x7f84059612c0&gt; ## &lt;environment: 0x7f8405966e28&gt; ## Methods may be defined for arguments: x, envir ## Use showMethods(&quot;.prioritizeDotPlotData&quot;) for currently available ones. showMethods(&quot;.prioritizeDotPlotData&quot;) ## Function: .prioritizeDotPlotData (package iSEE) ## x=&quot;DotPlot&quot; .colorByNoneDotPlotField() and .colorByNoneDotPlotScale() define the default color scale when ColorBy=\"None\". This usually doesn’t need to be specialized. getGeneric(&quot;.colorByNoneDotPlotField&quot;) ## standardGeneric for &quot;.colorByNoneDotPlotField&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.colorByNoneDotPlotField&quot;) ## &lt;bytecode: 0x7f8405af2568&gt; ## &lt;environment: 0x7f8405af5bc8&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.colorByNoneDotPlotField&quot;) for currently available ones. showMethods(&quot;.colorByNoneDotPlotField&quot;) ## Function: .colorByNoneDotPlotField (package iSEE) ## x=&quot;DotPlot&quot; getGeneric(&quot;.colorByNoneDotPlotScale&quot;) ## standardGeneric for &quot;.colorByNoneDotPlotScale&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.colorByNoneDotPlotScale&quot;) ## &lt;bytecode: 0x7f84082015c0&gt; ## &lt;environment: 0x7f8408204fa0&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.colorByNoneDotPlotScale&quot;) for currently available ones. showMethods(&quot;.colorByNoneDotPlotScale&quot;) ## Function: .colorByNoneDotPlotScale (package iSEE) ## x=&quot;DotPlot&quot; 2.5.3 For metadata DotPlots .allowableYAxisChoices() and .allowableXAxisChoices() specifies the acceptable fields to put on the x- or y-axes of ColumnDataPlot or RowDataPlot subclasses. This is typically used to constrain the choices for customized panels that only accept certain column names or types. For example, a hypothetical MA plot panel would only accept log-fold changes on the y-axis. getGeneric(&quot;.allowableYAxisChoices&quot;) ## standardGeneric for &quot;.allowableYAxisChoices&quot; defined from package &quot;iSEE&quot; ## ## function (x, se) ## standardGeneric(&quot;.allowableYAxisChoices&quot;) ## &lt;bytecode: 0x7f8405b68370&gt; ## &lt;environment: 0x7f8405b6ad90&gt; ## Methods may be defined for arguments: x, se ## Use showMethods(&quot;.allowableYAxisChoices&quot;) for currently available ones. showMethods(&quot;.allowableYAxisChoices&quot;) ## Function: .allowableYAxisChoices (package iSEE) ## x=&quot;ColumnDataPlot&quot; ## x=&quot;RowDataPlot&quot; getGeneric(&quot;.allowableXAxisChoices&quot;) ## standardGeneric for &quot;.allowableXAxisChoices&quot; defined from package &quot;iSEE&quot; ## ## function (x, se) ## standardGeneric(&quot;.allowableXAxisChoices&quot;) ## &lt;bytecode: 0x7f8405b8a530&gt; ## &lt;environment: 0x7f8405b8ce70&gt; ## Methods may be defined for arguments: x, se ## Use showMethods(&quot;.allowableXAxisChoices&quot;) for currently available ones. showMethods(&quot;.allowableXAxisChoices&quot;) ## Function: .allowableXAxisChoices (package iSEE) ## x=&quot;ColumnDataPlot&quot; ## x=&quot;RowDataPlot&quot; 2.5.4 For Tables .generateTable() creates the data.frame that is rendered into the table widget for Table subclasses. Each row of the data.frame is generally expected to correspond to a row or column of the dataset. If this is specialized, there is usually no need to specialize .generateOutput(). getGeneric(&quot;.generateTable&quot;) ## standardGeneric for &quot;.generateTable&quot; defined from package &quot;iSEE&quot; ## ## function (x, envir) ## standardGeneric(&quot;.generateTable&quot;) ## &lt;bytecode: 0x7f8406b2c278&gt; ## &lt;environment: 0x7f8406b37058&gt; ## Methods may be defined for arguments: x, envir ## Use showMethods(&quot;.generateTable&quot;) for currently available ones. showMethods(&quot;.generateTable&quot;) ## Function: .generateTable (package iSEE) ## x=&quot;ColumnDataTable&quot; ## x=&quot;RowDataTable&quot; 2.6 Handling selections 2.6.1 Multiple .multiSelectionDimension() specifies whether the panel transmits multiple selections along the rows or columns. It can also be used to indicate that the panel does not transmit anything. getGeneric(&quot;.multiSelectionDimension&quot;) ## standardGeneric for &quot;.multiSelectionDimension&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.multiSelectionDimension&quot;) ## &lt;bytecode: 0x7f84059fcd10&gt; ## &lt;environment: 0x7f8405a0c600&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.multiSelectionDimension&quot;) for currently available ones. showMethods(&quot;.multiSelectionDimension&quot;) ## Function: .multiSelectionDimension (package iSEE) ## x=&quot;ColumnDotPlot&quot; ## x=&quot;ColumnTable&quot; ## x=&quot;Panel&quot; ## x=&quot;RowDotPlot&quot; ## x=&quot;RowTable&quot; .multiSelectionActive() returns the parameters that define the “active” multiple selection in the current panel. This is defined as the selection that the user can actively change by interacting with the panel. (In contrast, the “saved” selections are fixed and can only be deleted.) getGeneric(&quot;.multiSelectionActive&quot;) ## standardGeneric for &quot;.multiSelectionActive&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.multiSelectionActive&quot;) ## &lt;bytecode: 0x7f8406abd600&gt; ## &lt;environment: 0x7f8406ac4368&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.multiSelectionActive&quot;) for currently available ones. showMethods(&quot;.multiSelectionActive&quot;) ## Function: .multiSelectionActive (package iSEE) ## x=&quot;DotPlot&quot; ## x=&quot;Panel&quot; ## x=&quot;Table&quot; .multiSelectionCommands() creates the character vector of row or column names for a multiple selection in the current panel. More specifically, it returns the commands that will then be evaluated to generate such character vectors. The identity of the selected rows/columns will ultimately be transmitted to other panels to affect their behavior. getGeneric(&quot;.multiSelectionCommands&quot;) ## standardGeneric for &quot;.multiSelectionCommands&quot; defined from package &quot;iSEE&quot; ## ## function (x, index) ## standardGeneric(&quot;.multiSelectionCommands&quot;) ## &lt;bytecode: 0x7f8405a23170&gt; ## &lt;environment: 0x7f8405a2dd40&gt; ## Methods may be defined for arguments: x, index ## Use showMethods(&quot;.multiSelectionCommands&quot;) for currently available ones. showMethods(&quot;.multiSelectionCommands&quot;) ## Function: .multiSelectionCommands (package iSEE) ## x=&quot;DotPlot&quot; ## x=&quot;Table&quot; .multiSelectionAvailable() reports how many total points are available for selection in the current panel. This is used for reporting “percent selected” statistics below each panel. getGeneric(&quot;.multiSelectionAvailable&quot;) ## standardGeneric for &quot;.multiSelectionAvailable&quot; defined from package &quot;iSEE&quot; ## ## function (x, contents) ## standardGeneric(&quot;.multiSelectionAvailable&quot;) ## &lt;bytecode: 0x7f840570ba88&gt; ## &lt;environment: 0x7f8405711468&gt; ## Methods may be defined for arguments: x, contents ## Use showMethods(&quot;.multiSelectionAvailable&quot;) for currently available ones. showMethods(&quot;.multiSelectionAvailable&quot;) ## Function: .multiSelectionAvailable (package iSEE) ## x=&quot;Panel&quot; .multiSelectionClear() eliminates the active multiple selection in the current panel. This is used to wipe selections in response to changes to the plot content that cause those selections to be invalid. getGeneric(&quot;.multiSelectionClear&quot;) ## standardGeneric for &quot;.multiSelectionClear&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.multiSelectionClear&quot;) ## &lt;bytecode: 0x7f84056ef4b0&gt; ## &lt;environment: 0x7f84056f8968&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.multiSelectionClear&quot;) for currently available ones. showMethods(&quot;.multiSelectionClear&quot;) ## Function: .multiSelectionClear (package iSEE) ## x=&quot;DotPlot&quot; ## x=&quot;Panel&quot; .multiSelectionRestricted() indicates whether the current panel’s data should be restricted to the rows/columns that it receives from an incoming multiple selection. This is used to determine how changes in the upstream transmitters should propagate through to the current panel’s children. getGeneric(&quot;.multiSelectionRestricted&quot;) ## standardGeneric for &quot;.multiSelectionRestricted&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.multiSelectionRestricted&quot;) ## &lt;bytecode: 0x7f84059b8e60&gt; ## &lt;environment: 0x7f84059c1de8&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.multiSelectionRestricted&quot;) for currently available ones. showMethods(&quot;.multiSelectionRestricted&quot;) ## Function: .multiSelectionRestricted (package iSEE) ## x=&quot;DotPlot&quot; ## x=&quot;Panel&quot; .multiSelectionInvalidated() indicates whether the current panel is invalidated when it receives a new multiple selection. This usually doesn’t need to be specialized. getGeneric(&quot;.multiSelectionInvalidated&quot;) ## standardGeneric for &quot;.multiSelectionInvalidated&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.multiSelectionInvalidated&quot;) ## &lt;bytecode: 0x7f84059d4fb0&gt; ## &lt;environment: 0x7f84059d8bf8&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.multiSelectionInvalidated&quot;) for currently available ones. showMethods(&quot;.multiSelectionInvalidated&quot;) ## Function: .multiSelectionInvalidated (package iSEE) ## x=&quot;Panel&quot; 2.6.2 Single .singleSelectionDimension() specifies whether the panel transmits single selections of a row or column. It can also be used to indicate that the panel does not transmit anything. getGeneric(&quot;.singleSelectionDimension&quot;) ## standardGeneric for &quot;.singleSelectionDimension&quot; defined from package &quot;iSEE&quot; ## ## function (x) ## standardGeneric(&quot;.singleSelectionDimension&quot;) ## &lt;bytecode: 0x7f8406a52650&gt; ## &lt;environment: 0x7f8406a5a030&gt; ## Methods may be defined for arguments: x ## Use showMethods(&quot;.singleSelectionDimension&quot;) for currently available ones. showMethods(&quot;.singleSelectionDimension&quot;) ## Function: .singleSelectionDimension (package iSEE) ## x=&quot;ColumnDotPlot&quot; ## x=&quot;ColumnTable&quot; ## x=&quot;Panel&quot; ## x=&quot;RowDotPlot&quot; ## x=&quot;RowTable&quot; .singleSelectionValue() determines the row or column that has been selected in the current panel. The identity of the row/column is passed onto other panels to affect their behavior. getGeneric(&quot;.singleSelectionValue&quot;) ## standardGeneric for &quot;.singleSelectionValue&quot; defined from package &quot;iSEE&quot; ## ## function (x, pObjects) ## standardGeneric(&quot;.singleSelectionValue&quot;) ## &lt;bytecode: 0x7f8406a105a8&gt; ## &lt;environment: 0x7f8406a16340&gt; ## Methods may be defined for arguments: x, pObjects ## Use showMethods(&quot;.singleSelectionValue&quot;) for currently available ones. showMethods(&quot;.singleSelectionValue&quot;) ## Function: .singleSelectionValue (package iSEE) ## x=&quot;DotPlot&quot; ## x=&quot;Table&quot; .singleSelectionSlots() determines how the current panel should respond to single selections from other panels. This will also automatically set up some of the more difficult observers if sufficient information is supplied by the class. getGeneric(&quot;.singleSelectionValue&quot;) ## standardGeneric for &quot;.singleSelectionValue&quot; defined from package &quot;iSEE&quot; ## ## function (x, pObjects) ## standardGeneric(&quot;.singleSelectionValue&quot;) ## &lt;bytecode: 0x7f8406a105a8&gt; ## &lt;environment: 0x7f8406a16340&gt; ## Methods may be defined for arguments: x, pObjects ## Use showMethods(&quot;.singleSelectionValue&quot;) for currently available ones. showMethods(&quot;.singleSelectionValue&quot;) ## Function: .singleSelectionValue (package iSEE) ## x=&quot;DotPlot&quot; ## x=&quot;Table&quot; "],
["server.html", "Chapter 3 Application state 3.1 Overview 3.2 Updating parameters 3.3 Using the memory 3.4 Responding to events", " Chapter 3 Application state 3.1 Overview iSEE uses global variables to keep track of the application state and to trigger reactive expressions. These are passed in the ubiquitous pObjects and rObjects arguments for non-reactive and reactive variables, respectively. Both of these objects have pass-by-reference semantics, meaning that any modifications to their contents within functions will persist outside of the function scope. Of particular relevance is the application memory in pObjects, which panels are expected to read and modify to respond to user interaction and generate output. Developers should also refrain from adding their own application-wide reactive variables, and should only modify the existing ones through a dedicated set of functions provided by iSEE. Respecting this paradigm will ensure that custom panels behave correctly in the context of the entire application. 3.2 Updating parameters The application memory is a list of Panel instances in pObjects$memory that captures the current state of the iSEE application. Conceptually, one should be able to extract this list from a running application, pass it to the initial= argument of the iSEE() function and expect to recover the same state. All modifications to the state should be recorded in the memory, meaning that observer expressions will commonly contain code like: pObjects$memory[[panel_name]][[param_name]] &lt;- new_value By itself, modifying the application memory will not trigger any further actions. The memory is too complex to be treated as a reactive value as it would affect too many downstream observers. Instead, we provide the .requestUpdate() function to indicate to the application that a particular panel needs to be updated. This sets a flag in rObjects that will eventually trigger re-rendering of the specified panel. The .requestCleanUpdate() function provides a variant of this approach where the panel should be updated and any active or saved multiple selections should be wiped. This is useful for dealing with changes to “protected” parameters that modify the panel contents such that any selection parameters are no longer relevant (e.g., invalidating brushes when the plot coordinates change). Yet another variant is the .requestActiveSelectionUpdate() function, which indicates whether a panel’s active multiple selection has changed; this should be used in the observer expression that responds to the panel’s multiple selection mechanism. The two-step process of memory modification and calling .requestUpdate() is facilitated by functions like .createUnprotectedParameterObservers(), which sets up simple observers for parameter modifications. However, more complex observers will have to do this manually. 3.3 Using the memory In a similar vein, expressions to render output should never touch the Shiny input object directly. (Indeed, .renderOutput() does not even have access to the input.) As all parameter changes pass through the memory, the updated values of each parameter should also be retrieved from memory. This involves extracting the desired Panel from pObjects$memory in methods for generics like .createObservers() that rely on pass-by-reference semantics for correct evaluation of reactive expressions. Other generics that are not setting up reactive expressions can directly extract values from the supplied Panel object. Each Panel object can be treated as a list of panel parameters. Retrieving values is as simple as using the [[ operator with the name of the parameter. Direct slot access should be avoided, consistent with best practice for S4 programming. 3.4 Responding to events Developers can respond to events by calling functions like .trackUpdate() within an observer or rendering expression. For example, .trackUpdate() will trigger re-evaluation of its context if the panel is updated by .requestUpdate(). Other variants like .trackMultiSelection() will trigger re-evaluation upon changes to the panel’s multiple selections. This is mostly intended for panels that need to synchronize updates to multiple output elements. Developers should only use these functions to track updates to the same panel for which the observer/rendering expression is written; management of communication across panels is outside of the scope of these expressions. "],
["developing.html", "Chapter 4 Reduced dimension hexbin plot 4.1 Overview 4.2 Class basics 4.3 Setting up the interface 4.4 Creating the observers 4.5 Generating the plot 4.6 In action", " Chapter 4 Reduced dimension hexbin plot 4.1 Overview In this example, we will create a panel class to show dimensionality reduction results using a hexbin plot. The idea is to improve plotting speed for large datasets by binning points rather than showing each point individually. Astute readers will note that the proposed class is the same as the ReducedDimensionHexPlot from iSEEu. This chapter will describe the most relevant aspects of the development process to create a reasonably functional class. 4.2 Class basics The choice of a parent class depends on the properties that we want that new panel class to start with. In this case, to create a panel that inherits all the functionality of the ReducedDimensionPlot panel type, we simply define a new class that extends that class. We will call the new class RedDimHexPlot, adding an extra parameter to control the resolution of the hexbins. setClass(&quot;RedDimHexPlot&quot;, contains=&quot;ReducedDimensionPlot&quot;, slots=c(BinResolution=&quot;numeric&quot;)) Any new slots should come with validity methods, as shown below. library(S4Vectors) setValidity2(&quot;RedDimHexPlot&quot;, function(object) { msg &lt;- character(0) if (length(val &lt;- object[[&quot;BinResolution&quot;]])!=1L || val &lt;= 0) { msg &lt;- c(msg, &quot;&#39;BinResolution&#39; must be a positive number&quot;) } if (length(msg)) { return(msg) } TRUE }) We specialize the initialize() method to provide a default for the new parameter. We also define a constructor function to make it easier to create a new instance. setMethod(&quot;initialize&quot;, &quot;RedDimHexPlot&quot;, function(.Object, BinResolution=100, ...) { callNextMethod(.Object, BinResolution=BinResolution, ...) }) RedDimHexPlot &lt;- function(...) { new(&quot;RedDimHexPlot&quot;, ...) } At this point, we can already create and use instances of this new panel class in iSEE apps. However, that would not be very exciting as instances of this new panel class would behave exactly like the those of the parent ReducedDimensionPlot class. Let’s define a few more methods to introduce some more relevant differences in behavior. 4.3 Setting up the interface Currently, instances of our new class are indistinguishable from the parent ReducedDimensionPlot in the iSEE interface. To differentiate our new class, we create a method for the .fullName() generic to show a different name. setMethod(&quot;.fullName&quot;, &quot;RedDimHexPlot&quot;, function(x) &quot;Reduced dimension hexagonal plot&quot;) While we’re here, we might as well give the panel a different color as well. setMethod(&quot;.panelColor&quot;, &quot;RedDimHexPlot&quot;, function(x) &quot;#AA5500&quot;) We also override aspects of the user interface to add a parameter to modify the bin resolution. Here, we place a numericInput widget into the set of parameters controlling the size aesthetics. setMethod(&quot;.defineVisualSizeInterface&quot;, &quot;RedDimHexPlot&quot;, function(x) { plot_name &lt;- .getEncodedName(x) tagList( numericInput( paste0(plot_name, &quot;_&quot;, &quot;BinResolution&quot;), label=&quot;Bin resolution:&quot;, min=1, value=x[[&quot;BinResolution&quot;]], step = 1) ) }) Conversely, some other aspects of the UI are now irrelevant because we are no longer showing individual points. This includes the shape of the points, point-related downsampling and a variety of other aesthetic features. Thus, we hide or disable them to avoid cluttering the interface. setMethod(&quot;.hideInterface&quot;, &quot;RedDimHexPlot&quot;, function(x, field) { if (field == &quot;Downsample&quot;) TRUE else callNextMethod() }) setMethod(&quot;.defineVisualShapeInterface&quot;, &quot;RedDimHexPlot&quot;, function(x) { NULL }) setMethod(&quot;.defineVisualOtherInterface&quot;, &quot;RedDimHexPlot&quot;, function(x) { NULL }) 4.4 Creating the observers The only new UI element we added was the widget to control the bin resolution. Thus, the only new observer that needs to be added is the one that respects to this element. Note the use of callNextMethod() to ensure that the observers for the parent class are also instantiated. setMethod(&quot;.createObservers&quot;, &quot;RedDimHexPlot&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) .createProtectedParameterObservers(plot_name, fields=c(&quot;BinResolution&quot;), input=input, pObjects=pObjects, rObjects=rObjects) invisible(NULL) }) 4.5 Generating the plot We create a method for the .generateDotPlot() generic to implement our hexbinning strategy. The contract for this generic guarantees that our method can immediately rely on the plot.data data-frame that is computed by methods defined for the parent ReducedDimensionPlot class. We also use the precomputed aesthetic labels associated with each column of plot.data, while setting a fixed label \"Count\" for the fill aesthetic associated with the count of observation in each hexagonal bin. library(ggplot2) setMethod(&quot;.generateDotPlot&quot;, &quot;RedDimHexPlot&quot;, function(x, labels, envir) { plot_cmds &lt;- list() plot_cmds[[&quot;ggplot&quot;]] &lt;- &quot;dot.plot &lt;- ggplot() +&quot; # Adding hexbins to the plot. plot_cmds[[&quot;hex&quot;]] &lt;- &quot;geom_hex(aes(X, Y), plot.data) +&quot; plot_cmds[[&quot;labs&quot;]] &lt;- &quot;labs(fill=&#39;Count&#39;) +&quot; plot_cmds[[&quot;labs&quot;]] &lt;- sprintf( &quot;labs(x=&#39;%s&#39;, y=&#39;%s&#39;, title=&#39;%s&#39;, fill=&#39;%s&#39;) +&quot;, labels$X, labels$Y, labels$title, &quot;Count&quot; ) plot_cmds[[&quot;theme_base&quot;]] &lt;- &quot;theme_bw() +&quot; plot_cmds[[&quot;theme_legend&quot;]] &lt;- &quot;theme(legend.position = &#39;bottom&#39;)&quot; # Adding a faceting command, if applicable. facet_cmd &lt;- .addFacets(x) if (length(facet_cmd)) { N &lt;- length(plot_cmds) plot_cmds[[N]] &lt;- paste(plot_cmds[[N]], &quot;+&quot;) plot_cmds &lt;- c(plot_cmds, facet_cmd) } # Adding self-brushing boxes, if they exist. plot_cmds &lt;- .addMultiSelectionPlotCommands(x, envir=envir, commands=plot_cmds) gg_plot &lt;- .textEval(plot_cmds, envir) list(plot=gg_plot, commands=plot_cmds) }) For brevity, we have omitted the more tiresome parts of coloring the bins with respect to assay values or metadata variables. However, it is relatively straightforward to extend .generateDotPlot() to ensure that it responds to such choices as well as any other relevant parameters in x (e.g., font size). 4.6 In action To demonstrate, we will load a small example dataset (Tasic et al. 2016) from the scRNAseq package. This is provided as a SingleCellExperiment on which we compute the usual \\(t\\)-SNE plot. library(scRNAseq) sce &lt;- ReprocessedAllenData(assays=&quot;tophat_counts&quot;) set.seed(100) library(scater) sce &lt;- logNormCounts(sce, exprs_values=&quot;tophat_counts&quot;) sce &lt;- runPCA(sce, ncomponents=4) sce &lt;- runTSNE(sce) We now set up an iSEE() instance with the hexbin and standard plots for showing reduced dimension results. We can see the obvious visual differences in the aesthetics between plots as well as the changes to the user interface. app &lt;- iSEE(sce, initial=list( ReducedDimensionPlot(Type=&quot;TSNE&quot;, VisualBoxOpen=TRUE, VisualChoices=&quot;Size&quot;, PanelWidth=6L), RedDimHexPlot(Type=&quot;TSNE&quot;, VisualBoxOpen=TRUE, VisualChoices=&quot;Size&quot;, PanelWidth=6L) )) References "],
["dynamic-reduced-dimensions.html", "Chapter 5 Dynamic reduced dimensions 5.1 Overview 5.2 Class basics 5.3 Setting up the interface 5.4 Creating the observers 5.5 Making the plot 5.6 In action", " Chapter 5 Dynamic reduced dimensions 5.1 Overview In this case study, we will create a custom panel class to regenerate sample-level PCA coordinates using only a subset of points transmitted as a multiple column selection from another panel. We call this a dynamic reduced dimension plot, as it is dynamically recomputing the dimensionality reduction results rather than using pre-computed values in the reducedDims() slot of a SingleCellExperiment object. This proposed class is the basis of the DynamicReducedDimensionPlot from the iSEEu package. 5.2 Class basics First, we define the basics of our new Panel class. As our new class will be showing each sample as a point, we inherit from the ColumnDotPlot virtual class. This automatically gives us access to all the functionality promised in the contract, including interface elements and observers to handle multiple selections and respond to aesthetic parameters. We add a slot specifying the type of dimensionality reduction result and the number of highly variable genes to use. Any new slots should also come with validity methods, as shown below. library(S4Vectors) setValidity2(&quot;DynRedDimPlot&quot;, function(object) { msg &lt;- character(0) if (length(n &lt;- object[[&quot;NGenes&quot;]])!=1L || n &lt; 1L) { msg &lt;- c(msg, &quot;&#39;NGenes&#39; must be a positive integer scalar&quot;) } if (!isSingleString(val &lt;- object[[&quot;Type&quot;]]) || !val %in% c(&quot;PCA&quot;, &quot;TSNE&quot;, &quot;UMAP&quot;)) { msg &lt;- c(msg, &quot;&#39;Type&#39; must be one of &#39;TSNE&#39;, &#39;PCA&#39; or &#39;UMAP&#39;&quot;) } if (length(msg)) { return(msg) } TRUE }) We specialize the initialize() method to provide a default for new parameters. We also implement a constructor for instances of this class. setMethod(&quot;initialize&quot;, &quot;DynRedDimPlot&quot;, function(.Object, Type=&quot;PCA&quot;, NGenes=1000L, ...) { callNextMethod(.Object, Type=Type, NGenes=NGenes, ...) }) DynRedDimPlot &lt;- function(...) { new(&quot;DynRedDimPlot&quot;, ...) } 5.3 Setting up the interface The most basic requirement is to define some methods that describe our new panel in the iSEE() interface. This includes defining the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;DynRedDimPlot&quot;, function(x) &quot;Dynamic reduced dimension plot&quot;) setMethod(&quot;.panelColor&quot;, &quot;DynRedDimPlot&quot;, function(x) &quot;#0F0F0F&quot;) We also add interface elements to change the result type and the number of genes. This is most easily done by specializing the .defineDataInterface method: library(shiny) setMethod(&quot;.defineDataInterface&quot;, &quot;DynRedDimPlot&quot;, function(x, se, select_info) { plot_name &lt;- .getEncodedName(x) list( selectInput(paste0(plot_name, &quot;_Type&quot;), label=&quot;Type:&quot;, choices=c(&quot;PCA&quot;, &quot;TSNE&quot;, &quot;UMAP&quot;), selected=x[[&quot;Type&quot;]]), numericInput(paste0(plot_name, &quot;_NGenes&quot;), label=&quot;Number of HVGs:&quot;, min=1, value=x[[&quot;NGenes&quot;]]) ) }) We call .getEncodedName() to obtain a unique name for the current instance of our panel, e.g., DynRedDimPlot1. We then paste0 the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel; otherwise, multiple DynRedDimPlots would override each other. One can imagine this as a poor man’s Shiny module. 5.4 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. Note the use of callNextMethod() to ensure that observers of the parent class are also created; this automatically ensures that we can respond to changes in parameters provided by ColumnDotPlot. setMethod(&quot;.createObservers&quot;, &quot;DynRedDimPlot&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) .createProtectedParameterObservers(plot_name, fields=c(&quot;Type&quot;, &quot;NGenes&quot;), input=input, pObjects=pObjects, rObjects=rObjects) }) Both the NGenes and Type parameters are what we consider to be “protected” parameters, as changing them will alter the nature of the displayed plot. We use the .createProtectedParameterObservers() utility to set up observers for both parameters, which will instruct iSEE() to destroy existing brushes and lassos when these parameters are changed. The idea here is that brushes/lassos made on the previous plot do not make sense when the coordinates are recomputed. For this particular panel class, an additional helpful feature is to override .multiSelectionInvalidated. This indicates that any brushes or lassos in our plot should be destroyed when we receive a new column selection. Doing so is the only sensible course of action as the reduced dimension coordinates for one set of samples have no obvious relationship to the coordinates for another set of samples; having old brushes or lassos hanging around would be of no benefit at best, and be misleading at worst. setMethod(&quot;.multiSelectionInvalidated&quot;, &quot;DynRedDimPlot&quot;, function(x) TRUE) 5.5 Making the plot When working with a ColumnDotPlot subclass, the easiest way to change plotting content to override the .generateDotPlotData method. This should add a plot.data variable to the envir environment that has columns X and Y and contains one row per column of the original SummarizedExperiment. It should also return a character vector of R commands describing how that plot.data object was constructed. The easiest way to do this is to create a character vector of commands and call eval(parse(text=...), envir=envir) to evaluate them within envir. setMethod(&quot;.generateDotPlotData&quot;, &quot;DynRedDimPlot&quot;, function(x, envir) { commands &lt;- character(0) if (!exists(&quot;col_selected&quot;, envir=envir, inherits=FALSE)) { commands &lt;- c(commands, &quot;plot.data &lt;- data.frame(X=numeric(0), Y=numeric(0));&quot;) } else { commands &lt;- c(commands, &quot;.chosen &lt;- unique(unlist(col_selected));&quot;, &quot;set.seed(100000)&quot;, # to avoid problems with randomization. sprintf(&quot;.coords &lt;- scater::calculate%s(se[,.chosen], ntop=%i, ncomponents=2);&quot;, x[[&quot;Type&quot;]], x[[&quot;NGenes&quot;]]), &quot;plot.data &lt;- data.frame(.coords, row.names=.chosen);&quot;, &quot;colnames(plot.data) &lt;- c(&#39;X&#39;, &#39;Y&#39;);&quot; ) } commands &lt;- c(commands, &quot;plot.data &lt;- plot.data[colnames(se),,drop=FALSE];&quot;, &quot;rownames(plot.data) &lt;- colnames(se);&quot;) eval(parse(text=commands), envir=envir) list(data_cmds=commands, plot_title=sprintf(&quot;Dynamic %s plot&quot;, x[[&quot;Type&quot;]]), x_lab=paste0(x[[&quot;Type&quot;]], &quot;1&quot;), y_lab=paste0(x[[&quot;Type&quot;]], &quot;2&quot;)) }) We use functions from the scater package to do the actual heavy lifting of calculating the dimensionality reduction results. The exists() call will check whether any column selection is being transmitted to this panel; if not, it will just return a plot.data variable that contains all NAs such that an empty plot is created. If col_selected does exist, it will contain a list of character vectors specifying the active and saved multiple selections that are being transmitted. For this particular example, we do not care about the distinction between active/saved selections so we just take the union of all of them. Of course, this is not quite the most efficient way to implement a plotting panel that involves recomputation. A better approach would be to cache the x/y coordinates and reuse them if only aesthetic parameters have changed, thus avoiding an unnecessary delay from recomputation. Doing so requires overriding .renderOutput() to take advantage of the cached contents of the plot, so we will omit that here for simplicity. 5.6 In action Let’s put our new panel to the test. We’ll use the sce object from Chapter 4, which includes some precomputed dimensionality reduction results. The plan is to create a (fixed) reduced dimension plot that will transmit a multiple selection to our dynamic reduced dimension plot. Brushing at any location in the former will then trigger dynamic recompution of results in the latter. rdp &lt;- ReducedDimensionPlot(PanelId=1L, PanelWidth=6L, BrushData = list( xmin = 17, xmax = 55, ymin = -36, ymax = 29, coords_css = list(xmin = 300L, xmax = 450L, ymin = 170L, ymax = 404L), coords_img = list( xmin = 375L, xmax = 562, ymin = 212, ymax = 505L), img_css_ratio = list(x = 1, y = 1), mapping = list(x = &quot;X&quot;, y = &quot;Y&quot;), domain = list(left = -49, right = 57, bottom = -53, top = 70), range = list(left = 49, right = 570, bottom = 580, top = 31), log = list(x = NULL, y = NULL), direction = &quot;xy&quot;, brushId = &quot;ReducedDimensionPlot1_Brush&quot;, outputId = &quot;ReducedDimensionPlot1&quot; ) ) drdp &lt;- DynRedDimPlot(DataBoxOpen=TRUE, ColumnSelectionSource=&quot;ReducedDimensionPlot1&quot;, PanelWidth=6L) app &lt;- iSEE(sce, initial=list(rdp, drdp)) "],
["dynamic-differential-expression.html", "Chapter 6 Dynamic differential expression 6.1 Overview 6.2 Class basics 6.3 Setting up the interface 6.4 Creating the observers 6.5 Making the table 6.6 In action", " Chapter 6 Dynamic differential expression 6.1 Overview In this case study, we will create a panel class to dynamically compute differential expression (DE) statistics between the active sample-level selection and the other saved selections from a transmitting panel. We will present the results of this computation in a DataTable widget from the DT package, where each row is a gene and each column is a relevant statistic (\\(p\\)-value, FDR, log-fold changes, etc.). The class proposed here is the basis of the DifferentialStatsticsTable from iSEEu. 6.2 Class basics First, we define the basics of our new Panel class. As our new class will be showing each gene as a row, we inherit from the RowTable virtual class. This automatically gives us access to all the functionality promised in the contract, including interface elements and observers to respond to multiple selections. We also add a slot specifying the log-fold change threshold to use in the null hypothesis. Any new slots should come with validity methods, as shown below. library(S4Vectors) setValidity2(&quot;DGETable&quot;, function(object) { msg &lt;- character(0) if (length(val &lt;- object[[&quot;LogFC&quot;]])!=1L || val &lt; 0) { msg &lt;- c(msg, &quot;&#39;NGenes&#39; must be a non-negative number&quot;) } if (length(msg)) { return(msg) } TRUE }) It is also worthwhile specializing the initialize() method to provide a default for new parameters. We hard-code the ColumnSelectionType setting as we want to obtain all multiple selections from the transmitting panel, in order to be able to perform pairwise DE analyses between the various active and saved selections. (By comparison, the default of \"Active\" will only transmit the current active selection.) We also define a constructor to conveniently create new instances. setMethod(&quot;initialize&quot;, &quot;DGETable&quot;, function(.Object, LogFC=0, ...) { callNextMethod(.Object, LogFC=LogFC, ColumnSelectionType=&quot;Union&quot;, ...) }) DGETable &lt;- function(...) { new(&quot;DGETable&quot;, ...) } 6.3 Setting up the interface The most basic requirement is to define some methods that describe our new panel in the iSEE() interface. This includes defining the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;DGETable&quot;, function(x) &quot;Differential expression table&quot;) setMethod(&quot;.panelColor&quot;, &quot;DGETable&quot;, function(x) &quot;#55AA00&quot;) We also add interface elements to change the result type and the number of genes. This is most easily done by specializing the .defineDataInterface() generic. We paste0 the name of our panel to the name of any parameter to ensure that the ID is unique to this instance of our panel. library(shiny) setMethod(&quot;.defineDataInterface&quot;, &quot;DGETable&quot;, function(x, se, select_info) { plot_name &lt;- .getEncodedName(x) list( numericInput(paste0(plot_name, &quot;_LogFC&quot;), label=&quot;Log-FC threshold&quot;, min=0, value=x[[&quot;LogFC&quot;]]) ) }) By default, all RowTables hide their multiple column selection parameter choices. This considers the typical use case where RowTables respond to a selection of rows rather than a selection of columns. For DGETables, we need to flip this around by specializing .hideInterface() so that the unresponsive row selection parameters are hidden in the interface while the useful column selection parameters are visible. setMethod(&quot;.hideInterface&quot;, &quot;DGETable&quot;, function(x, field) { if (field %in% c(&quot;RowSelectionSource&quot;, &quot;RowSelectionType&quot;, &quot;RowSelectionSaved&quot;, &quot;RowSelectionDynamicSource&quot;)) { TRUE } else if (field %in% &quot;ColumnSelectionSource&quot;) { FALSE } else { callNextMethod() } }) A more advanced version of this panel class might consider responding to a row selection by only performing the DE analysis on the selected features. In such cases, we would not need to hide RowSelectionSource, though we will leave that as an exercise for the curious. 6.4 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. Note the use of callNextMethod() to ensure that observers of the parent class are also created; this automatically ensures that we can respond to changes in parameters provided by RowTable. setMethod(&quot;.createObservers&quot;, &quot;DGETable&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) .createUnprotectedParameterObservers(plot_name, fields=&quot;LogFC&quot;, input=input, pObjects=pObjects, rObjects=rObjects) }) The distinction between protected and unprotected parameters is less important for Tables; as long as the types of the columns do not change between renderings, any column or global selections (i.e., search terms) are usually still sensible. 6.5 Making the table When working with a RowTable subclass, the easiest way to change plotting content to override the .generateTable method. This is expected to generate a data.frame in the evaluation environment, returning the commands required to do so. In this case, we want to perform one-sided \\(t\\)-tests between the active selection and any number of saved selections. We will use the findMarkers() function from scran to compute the desired statistics. This performs all pairwise comparisons, so is not as efficient as could be, but it will suffice for this demonstration. setMethod(&quot;.generateTable&quot;, &quot;DGETable&quot;, function(x, envir) { empty &lt;- &quot;tab &lt;- data.frame(Top=integer(0), p.value=numeric(0), FDR=numeric(0));&quot; if (!exists(&quot;col_selected&quot;, envir, inherits=FALSE) || length(envir$col_selected)&lt;2L || !&quot;active&quot; %in% names(envir$col_selected)) { commands &lt;- empty } else { commands &lt;- c(&quot;.chosen &lt;- unlist(col_selected);&quot;, &quot;.grouping &lt;- rep(names(col_selected), lengths(col_selected));&quot;, sprintf(&quot;.de.stats &lt;- scran::findMarkers(logcounts(se)[,.chosen], .grouping, direction=&#39;up&#39;, lfc=%s)&quot;, x[[&quot;LogFC&quot;]]), &quot;tab &lt;- as.data.frame(.de.stats[[&#39;active&#39;]]);&quot; ) } eval(parse(text=commands), envir=envir) list(commands=commands, contents=envir$tab) }) Readers may notice that we prefix internal variables with . in our commands. This ensures that they do not clash with global variables created by iSEE() itself (which is not an issue when running the app, but makes things difficult when the code is reported for tracking purposes). 6.6 In action Let’s put our new panel to the test. We’ll use the sce object from Chapter 4, which includes some precomputed dimensionality reduction results. The plan is to create a (fixed) reduced dimension plot that will transmit to our DGE table. We set up an iSEE instance with an existing brush on the former to trigger computation of differential results by the latter. # Setting up multiple active and saved brushes. rdp &lt;- ReducedDimensionPlot(PanelId=1L, BrushData = list( xmin = 17, xmax = 55, ymin = -36, ymax = 29, coords_css = list(xmin = 300L, xmax = 450L, ymin = 170L, ymax = 404L), coords_img = list( xmin = 375L, xmax = 562, ymin = 212, ymax = 505L), img_css_ratio = list(x = 1, y = 1), mapping = list(x = &quot;X&quot;, y = &quot;Y&quot;), domain = list(left = -49, right = 57, bottom = -53, top = 70), range = list(left = 49, right = 570, bottom = 580, top = 31), log = list(x = NULL, y = NULL), direction = &quot;xy&quot;, brushId = &quot;ReducedDimensionPlot1_Brush&quot;, outputId = &quot;ReducedDimensionPlot1&quot; ), SelectionHistory = list( list( xmin = -44, xmax = -1, ymin = 5, ymax = 59, coords_css = list(xmin = 57L, xmax = 225L, ymin = 64L, ymax = 254L), coords_img = list(xmin = 71, xmax = 281, ymin = 80L, ymax = 317), img_css_ratio = list(x = 1, y = 1), mapping = list(x = &quot;X&quot;, y = &quot;Y&quot;), domain = list(left = -49, right = 57, bottom = -53, top = 70), range = list(left = 49, right = 570, bottom = 580, top = 31), log = list(x = NULL, y = NULL), direction = &quot;xy&quot;, brushId = &quot;ReducedDimensionPlot1_Brush&quot;, outputId = &quot;ReducedDimensionPlot1&quot; ) ) ) dget &lt;- DGETable(ColumnSelectionSource=&quot;ReducedDimensionPlot1&quot;, PanelWidth=8L, DataBoxOpen=TRUE) app &lt;- iSEE(sce, initial=list(rdp, dget)) "],
["annotated-gene-list.html", "Chapter 7 Annotated gene list 7.1 Overview 7.2 Class basics 7.3 Setting up the interface 7.4 Creating the observers 7.5 In action", " Chapter 7 Annotated gene list 7.1 Overview When given a gene list, we often need to look up the function of the top genes in a search engine. This typically involves copy-pasting the gene name or ID into the search box and pressing Enter, which is a pain. Instead, we can automate this process in iSEE by creating an annotated gene table that dynamically looks up annotation for each gene in the rowData of a SummarizedExperiment. 7.2 Class basics First, we define the basics of our new Panel class. Our new class will be showing the gene-level metadata, so we inherit from the RowDataTable class that does exactly this. We add some slots specifying which column of the table contains our gene IDs, the type of ID and the organism database to use. library(iSEE) library(S4Vectors) setClass(&quot;GeneAnnoTable&quot;, contains=&quot;RowDataTable&quot;, slots=c( IDColumn=&quot;character_OR_NULL&quot;, IDType=&quot;character&quot;, Organism=&quot;character&quot;, AnnoBoxOpen=&quot;logical&quot; ) ) We specialize the validity method to check that the IDColumn is either a string or NULL; if the latter, we assume that the ID is stored in the row name. We also add some cursory checks for the other parameters. allowable &lt;- c(&quot;ENSEMBL&quot;, &quot;SYMBOL&quot;, &quot;ENTREZID&quot;) setValidity2(&quot;GeneAnnoTable&quot;, function(object) { msg &lt;- character(0) if (!is.null(val &lt;- object[[&quot;IDColumn&quot;]]) &amp;&amp; (length(val)!=1L || is.na(val))) { msg &lt;- c(msg, &quot;&#39;IDColumn must be NULL or a string&quot;) } if (!isSingleString(orgdb &lt;- object[[&quot;Organism&quot;]])) { msg &lt;- c(msg, sprintf(&quot;&#39;Organism&#39; should be a single string&quot;, orgdb)) } if (!isSingleString(type &lt;- object[[&quot;IDType&quot;]]) || !type %in% allowable) { msg &lt;- c(msg, &quot;&#39;IDType&#39; should be &#39;ENSEMBL&#39;, &#39;SYMBOL&#39; or &#39;ENTREZID&#39;&quot;) } if (length(open &lt;- object[[&quot;AnnoBoxOpen&quot;]])!=1L || is.na(open)) { msg &lt;- c(msg, &quot;&#39;AnnoBoxOpen&#39; should be a non-missing logical scalar&quot;) } if (length(msg)) { return(msg) } TRUE }) We then specialize the initialize method to set reasonable defaults for these parameters. We also provide a constructor to conveniently create new instances. setMethod(&quot;initialize&quot;, &quot;GeneAnnoTable&quot;, function(.Object, IDColumn=NULL, Organism=&quot;org.Mm.eg.db&quot;, IDType=&quot;SYMBOL&quot;, AnnoBoxOpen=FALSE, ...) { callNextMethod(.Object, IDColumn=IDColumn, IDType=IDType, Organism=Organism, AnnoBoxOpen=AnnoBoxOpen, ...) }) GeneAnnoTable &lt;- function(...) { new(&quot;GeneAnnoTable&quot;, ...) } 7.3 Setting up the interface We define the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;GeneAnnoTable&quot;, function(x) &quot;Annotated gene table&quot;) setMethod(&quot;.panelColor&quot;, &quot;GeneAnnoTable&quot;, function(x) &quot;#AA1122&quot;) We want to add another UI element for showing the gene-level annotation. This is achieved by specializing the .defineOutput() method as shown below; note the prefixing by the panel name to ensure that output element IDs from different panels are unique. setMethod(&quot;.defineOutput&quot;, &quot;GeneAnnoTable&quot;, function(x, ...) { panel_name &lt;- .getEncodedName(x) tagList( callNextMethod(), # Re-using RowDataTable&#39;s definition. uiOutput(paste0(panel_name, &quot;_annotation&quot;)), hr() ) }) We also set up interface elements for changing the annotation parameters. We will put these elements in a separate “Annotation parameters” collapsible box, which is initialized in an opened or closed state depending on the AnnoBoxOpen slot. setMethod(&quot;.defineInterface&quot;, &quot;GeneAnnoTable&quot;, function(x, se, select_info) { panel_name &lt;- .getEncodedName(x) c( list( collapseBox( paste0(panel_name, &quot;_AnnoBoxOpen&quot;), title=&quot;Annotation parameters&quot;, open=x[[&quot;AnnoBoxOpen&quot;]], selectInput(paste0(panel_name, &quot;_IDColumn&quot;), label=&quot;ID-containing column:&quot;, choices=colnames(rowData(se)), selected=x[[&quot;IDColumn&quot;]] ), selectInput(paste0(panel_name, &quot;_IDType&quot;), label=&quot;ID type:&quot;, choices=allowable, selected=x[[&quot;IDType&quot;]] ), selectInput(paste0(panel_name, &quot;_Organism&quot;), label=&quot;Organism&quot;, choices=c(&quot;org.Hs.eg.db&quot;, &quot;org.Mm.eg.db&quot;), selected=x[[&quot;Organism&quot;]] ) ) ), callNextMethod() ) }) 7.4 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. Note the use of callNextMethod() to ensure that observers of the parent class are also created. setMethod(&quot;.createObservers&quot;, &quot;GeneAnnoTable&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() plot_name &lt;- .getEncodedName(x) .createUnprotectedParameterObservers(plot_name, fields=c(&quot;IDColumn&quot;, &quot;Organism&quot;, &quot;IDType&quot;), input=input, pObjects=pObjects, rObjects=rObjects) }) We need to set up a rendering expression for the annotation element that responds to the selected gene. By using .trackSingleSelection(), we ensure that this UI element updates in response to changes in the table selection. We add a series of protective measures to avoid the application crashing due to missing organism packages or unmatched IDs. setMethod(&quot;.renderOutput&quot;, &quot;GeneAnnoTable&quot;, function(x, se, ..., output, pObjects, rObjects) { callNextMethod() # Re-using RowDataTable&#39;s output rendering. panel_name &lt;- .getEncodedName(x) output[[paste0(panel_name, &quot;_annotation&quot;)]] &lt;- renderUI({ .trackSingleSelection(panel_name, rObjects) instance &lt;- pObjects$memory[[panel_name]] rowdata_col &lt;- instance[[&quot;IDColumn&quot;]] selectedGene &lt;- instance[[&quot;Selected&quot;]] if (!is.null(rowdata_col)) { selectedGene &lt;- rowData(se)[selectedGene,rowdata_col] } keytype &lt;- instance[[&quot;IDType&quot;]] selgene_entrez &lt;- NA if (keytype!=&quot;ENTREZID&quot;) { ORG &lt;- instance[[&quot;Organism&quot;]] if (require(ORG, character.only=TRUE, quietly=TRUE)) { orgdb &lt;- get(ORG) selgene_entrez &lt;- try(mapIds(orgdb, selectedGene, &quot;ENTREZID&quot;, keytype), silent=TRUE) } } else { selgene_entrez &lt;- selectedGene } if (is.na(selgene_entrez) || is(selgene_entrez, &quot;try-error&quot;)) { return(NULL) } fullinfo &lt;- rentrez::entrez_summary(&quot;gene&quot;, selgene_entrez) link_pubmed &lt;- paste0(&#39;&lt;a href=&quot;http://www.ncbi.nlm.nih.gov/gene/?term=&#39;, selgene_entrez, &#39;&quot; target=&quot;_blank&quot;&gt;Click here to see more at the NCBI database&lt;/a&gt;&#39;) mycontent &lt;- paste0(&quot;&lt;b&gt;&quot;,fullinfo$name, &quot;&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;&quot;, fullinfo$description,&quot;&lt;br/&gt;&lt;br/&gt;&quot;, ifelse(fullinfo$summary == &quot;&quot;,&quot;&quot;,paste0(fullinfo$summary, &quot;&lt;br/&gt;&lt;br/&gt;&quot;)), link_pubmed) HTML(mycontent) }) }) Observant readers will note that the body of the rendering expression uses pObjects$memory[[panel_name]] rather than x. This is intentional as it ensures that we are using the parameter settings from the current state of the app. If we used x, we would always be using the parameters from the initial state of the app, which is not what we want. 7.5 In action Let’s put our new panel to the test using the sce object from Chapter 4. We set up our iSEE instance such that clicking on any row will bring up the Entrez annotation (if available) for that feature. It is probably best to click on some well-annotated genes as the set of RIKEN transcripts at the front don’t have much annotation. gat &lt;- GeneAnnoTable(PanelWidth=8L, Selected=&quot;Snap25&quot;, Search=&quot;Snap&quot;) app &lt;- iSEE(sce, initial=list(gat)) "],
["gene-ontology-table.html", "Chapter 8 Gene ontology table 8.1 Overview 8.2 Class basics 8.3 Setting up the interface 8.4 Generating the output 8.5 Creating the observers 8.6 Handling selections 8.7 In action", " Chapter 8 Gene ontology table 8.1 Overview Here, we will construct a table of GO terms where selection of a row in the table causes transmission of a multiple selection of gene names. The aim is to enable us to transmit multiple row selections to other panels based on their membership of a gene set. This is a fairly involved example of creating a Panel subclass as we cannot easily inherit from an existing subclass; rather, we need to provide all the methods ourselves. Readers may also be interested in the fully fledged version of the proposed class in iSEEu. 8.2 Class basics First, we define the basics of our new GOTable class. This inherits from the virtual base Panel class as it cannot meet any of the contractual requirements of the subclasses, what with the DataTable selection event triggering a multiple selection rather than a single selection. We add some slots to specify the feature ID type and the organism of interest as well as for DataTable parameters. library(iSEE) library(S4Vectors) setClass(&quot;GOTable&quot;, contains=&quot;Panel&quot;, slots=c( IDType=&quot;character&quot;, Organism=&quot;character&quot;, Selected=&quot;character&quot;, Search=&quot;character&quot;, SearchColumns=&quot;character&quot; ) ) We also add some checks for these parameters. allowable &lt;- c(&quot;ENSEMBL&quot;, &quot;SYMBOL&quot;, &quot;ENTREZID&quot;) setValidity2(&quot;GOTable&quot;, function(object) { msg &lt;- character(0) if (!isSingleString(orgdb &lt;- object[[&quot;Organism&quot;]])) { msg &lt;- c(msg, sprintf(&quot;&#39;Organism&#39; should be a single string&quot;, orgdb)) } if (!isSingleString(type &lt;- object[[&quot;IDType&quot;]]) || !type %in% allowable) { msg &lt;- c(msg, &quot;&#39;IDType&#39; should be &#39;ENSEMBL&#39;, &#39;SYMBOL&#39; or &#39;ENTREZID&#39;&quot;) } if (!isSingleString(object[[&quot;Selected&quot;]])) { msg &lt;- c(msg, &quot;&#39;Selected&#39; should be a single string&quot;) } if (!isSingleString(object[[&quot;Search&quot;]])) { msg &lt;- c(msg, &quot;&#39;Search&#39; should be a single string&quot;) } if (length(msg)) { return(msg) } TRUE }) We then specialize the initialize method to set reasonable defaults and create an approprpiate constructor. setMethod(&quot;initialize&quot;, &quot;GOTable&quot;, function(.Object, Organism=&quot;org.Mm.eg.db&quot;, IDType=&quot;SYMBOL&quot;, Selected=&quot;&quot;, Search=&quot;&quot;, SearchColumns=character(0), ...) { callNextMethod(.Object, IDType=IDType, Organism=Organism, Selected=Selected, Search=Search, SearchColumns=SearchColumns, ...) }) GOTable &lt;- function(...) new(&quot;GOTable&quot;, ...) 8.3 Setting up the interface We define the full name and desired default color for display purposes: setMethod(&quot;.fullName&quot;, &quot;GOTable&quot;, function(x) &quot;Gene ontology table&quot;) setMethod(&quot;.panelColor&quot;, &quot;GOTable&quot;, function(x) &quot;#BB00FF&quot;) We add our UI element for showing the gene set table, which is simply a DataTable object from the DT package. Note that shiny also has a dataTableOutput function so care must be taken to disambiguate them. setMethod(&quot;.defineOutput&quot;, &quot;GOTable&quot;, function(x, ...) { panel_name &lt;- .getEncodedName(x) tagList(DT::dataTableOutput(panel_name)) }) We set up interface elements for changing the annotation parameters. setMethod(&quot;.defineDataInterface&quot;, &quot;GOTable&quot;, function(x, se, select_info) { panel_name &lt;- .getEncodedName(x) list( selectInput(paste0(panel_name, &quot;_IDType&quot;), label=&quot;ID type:&quot;, choices=allowable, selected=x[[&quot;IDType&quot;]] ), selectInput(paste0(panel_name, &quot;_Organism&quot;), label=&quot;Organism&quot;, choices=c(&quot;org.Hs.eg.db&quot;, &quot;org.Mm.eg.db&quot;), selected=x[[&quot;Organism&quot;]] ) ) }) Our implementation will be a pure transmitter, i.e., it will not respond to row or column selections from other panels. To avoid confusion, we can hide all selection parameter UI elements by specializing the .hideInterface() method: setMethod(&quot;.hideInterface&quot;, &quot;GOTable&quot;, function(x, field) { if (field %in% &quot;SelectionBoxOpen&quot;) { TRUE } else { callNextMethod() } }) 8.4 Generating the output We actually generate the output by specializing the .generateOutput() function, using the GO.db package to create a table of GO terms and their definitions. We also store the number of available genes in the contents - this will be used later to compute the percentage of all genes in a given gene set. setMethod(&quot;.generateOutput&quot;, &quot;GOTable&quot;, function(x, se, ..., all_memory, all_contents) { envir &lt;- new.env() commands &lt;- c(&quot;require(GO.db);&quot;, &quot;tab &lt;- select(GO.db, keys=keys(GO.db), columns=&#39;TERM&#39;);&quot;, &quot;rownames(tab) &lt;- tab$GOID;&quot;, &quot;tab$GOID &lt;- NULL;&quot;) eval(parse(text=commands), envir=envir) list( commands=list(commands), contents=list(table=envir$tab, available=nrow(se)), varname=&quot;tab&quot; ) }) We don’t actually depend on any parameters of x itself to generate this table. However, one could imagine a more complex case where the GOTable itself responds to a multiple row selection, e.g., by subsetting to the gene sets that contain genes in the selected row. 8.5 Creating the observers We specialize .createObservers to define some observers to respond to changes in our new interface elements. This also involves creating an observer to respond to a change in the selection of a DataTable row, calling .requestActiveSelectionUpdate() to trigger changes in panels that are receiving the multiple row selection. (We set up observers for the search fields as well, as a courtesy to restore them properly upon re-rendering.) setMethod(&quot;.createObservers&quot;, &quot;GOTable&quot;, function(x, se, input, session, pObjects, rObjects) { callNextMethod() panel_name &lt;- .getEncodedName(x) .createUnprotectedParameterObservers(panel_name, fields=c(&quot;Organism&quot;, &quot;IDType&quot;), input=input, pObjects=pObjects, rObjects=rObjects) # Observer for the DataTable row selection: select_field &lt;- paste0(panel_name, &quot;_rows_selected&quot;) multi_name &lt;- paste0(panel_name, &quot;_&quot;, iSEE:::.flagMultiSelect) observeEvent(input[[select_field]], { chosen &lt;- input[[select_field]] if (length(chosen)==0L) { chosen &lt;- &quot;&quot; } else { chosen &lt;- rownames(pObjects$contents[[panel_name]]$table)[chosen] } previous &lt;- pObjects$memory[[panel_name]][[&quot;Selected&quot;]] if (chosen==previous) { return(NULL) } pObjects$memory[[panel_name]][[&quot;Selected&quot;]] &lt;- chosen .requestActiveSelectionUpdate(panel_name, session, pObjects, rObjects, update_output=FALSE) }, ignoreInit=TRUE, ignoreNULL=FALSE) # Observer for the search field: search_field &lt;- paste0(panel_name, &quot;_search&quot;) observeEvent(input[[search_field]], { search &lt;- input[[search_field]] if (identical(search, pObjects$memory[[panel_name]][[&quot;Search&quot;]])) { return(NULL) } pObjects$memory[[panel_name]][[&quot;Search&quot;]] &lt;- search }) # Observer for the column search fields: colsearch_field &lt;- paste0(panel_name, &quot;_search_columns&quot;) observeEvent(input[[colsearch_field]], { search &lt;- input[[colsearch_field]] if (identical(search, pObjects$memory[[panel_name]][[&quot;SearchColumns&quot;]])) { return(NULL) } pObjects$memory[[panel_name]][[&quot;SearchColumns&quot;]] &lt;- search }) }) Note the use of callNextMethod() to ensure that observers of the parent class are created. We also set ignoreInit=TRUE to avoid problems from ignoreNULL=TRUE when the observer is initialized before the table is rendered; otherwise, the NULL selection prior to table rendering will wipe out any initial setting for the Selected slot. We set up a rendering expression for the output table by specializing .renderOutput(). This uses the renderDataTable() function from the DT package (again, this has a similar-but-not-identical function in shiny, so be careful which one you import.) Some effort is involved in making sure that the output table responds to the memorized parameter values of our GOTable panel. setMethod(&quot;.renderOutput&quot;, &quot;GOTable&quot;, function(x, se, ..., output, pObjects, rObjects) { callNextMethod() panel_name &lt;- .getEncodedName(x) output[[panel_name]] &lt;- DT::renderDataTable({ .trackUpdate(panel_name, rObjects) param_choices &lt;- pObjects$memory[[panel_name]] t.out &lt;- .retrieveOutput(panel_name, se, pObjects, rObjects) full_tab &lt;- t.out$contents$table chosen &lt;- param_choices[[&quot;Selected&quot;]] search &lt;- param_choices[[&quot;Search&quot;]] search_col &lt;- param_choices[[&quot;SearchColumns&quot;]] search_col &lt;- lapply(search_col, FUN=function(x) { list(search=x) }) # If the existing row in memory doesn&#39;t exist in the current table, we # don&#39;t initialize it with any selection. idx &lt;- which(rownames(full_tab)==chosen)[1] if (!is.na(idx)) { selection &lt;- list(mode=&quot;single&quot;, selected=idx) } else { selection &lt;- &quot;single&quot; } DT::datatable( full_tab, filter=&quot;top&quot;, rownames=TRUE, options=list( search=list(search=search, smart=FALSE, regex=TRUE, caseInsensitive=FALSE), searchCols=c(list(NULL), search_col), # row names are the first column! scrollX=TRUE), selection=selection ) }) }) 8.6 Handling selections Now for the most important bit - configuring the GOTable to transmit a multiple row selection to other panels. This is achieved by specializing a series of .multiSelection*() methods. The first is the .multiSelectionDimension(), which controls the dimension being transmitted: setMethod(&quot;.multiSelectionDimension&quot;, &quot;GOTable&quot;, function(x) &quot;row&quot;) The next most important method is the .multiSelectionCommands(), which tells iSEE() how to create the multiple row selection from the selected DataTable row. It is expected to return a vector of commands that, when evaluated, creates a character vector of row names for transmission. This has an option (index) to differentiate between active and saved selections, though the latter case is not relevant to our GOTable so we will simply ignore it. We also need to protect against cases where the requested GO term is not found, upon which we simply return an empty character vector. setMethod(&quot;.multiSelectionCommands&quot;, &quot;GOTable&quot;, function(x, index) { orgdb &lt;- x[[&quot;Organism&quot;]] type &lt;- x[[&quot;IDType&quot;]] c( sprintf(&quot;require(%s);&quot;, orgdb), sprintf(&quot;selected &lt;- tryCatch(select(%s, keys=%s, keytype=&#39;GO&#39;, column=%s)$SYMBOL, error=function(e) character(0));&quot;, orgdb, deparse(x[[&quot;Selected&quot;]]), deparse(type)), &quot;selected &lt;- intersect(selected, rownames(se));&quot; ) }) We also define some generics to indicate whether a DataTable row is currently selected, and how to delete that selection. For the latter, we replace the selected row with an empty string to indicate that no selection has been made, consistent with the actions of our observer in .createObservers(). setMethod(&quot;.multiSelectionActive&quot;, &quot;GOTable&quot;, function(x) { if (x[[&quot;Selected&quot;]]!=&quot;&quot;) { x[[&quot;Selected&quot;]] } else { NULL } }) setMethod(&quot;.multiSelectionClear&quot;, &quot;GOTable&quot;, function(x) { x[[&quot;Selected&quot;]] &lt;- &quot;&quot; x }) Finally, we define a method to determine the total number of available genes. The default is to use the number of rows of the data.frame used in the datatable() call, but that would not be right for us as it represents the number of gene sets. Instead, we use the availability information that we previously stored in the contents during .generateOutput(). setMethod(&quot;.multiSelectionAvailable&quot;, &quot;GOTable&quot;, function(x, contents) { contents$available }) 8.7 In action Let’s put our new panel to the test using the sce object from Chapter 4. We set up an iSEE instance where clicking on any row in the GOTable will subset RowTable1 to only those genes in the corresponding GO term. got &lt;- GOTable(PanelWidth=8L, Selected=&quot;GO:0007049&quot;, Search=&quot;^cell cycle&quot;) rst &lt;- RowDataTable(RowSelectionSource=&quot;GOTable1&quot;) app &lt;- iSEE(sce, initial=list(got, rst)) "],
["contributors.html", "Chapter 9 Contributors", " Chapter 9 Contributors Aaron Lun 187 days of anime watched. Nuff said. Kevin Rue-Albrecht Je n’en crois pas mes yeux! "],
["references.html", "References", " References "]
]
